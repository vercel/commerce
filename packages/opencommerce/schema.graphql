directive @auth on FIELD_DEFINITION | OBJECT

"""
Represents a single user account
"""
type Account implements Node {
  """
  The account ID
  """
  _id: ID!

  """
  A list of physical or mailing addresses associated with this account
  """
  addressBook(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int
  ): AddressConnection

  """
  A list of shops this user can administer with the admin UI
  """
  adminUIShops: [Shop]

  """
  Bio to display on profile
  """
  bio: String

  """
  The date and time at which this account was created
  """
  createdAt: DateTime!

  """
  The preferred currency used by this account
  """
  currency: Currency

  """
  A list of email records associated with this account
  """
  emailRecords: [EmailRecord]

  """
  The first name of the person this account represents, if known
  """
  firstName: String

  """
  A paged list of the account groups in which this account is listed
  """
  groups(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: GroupSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): GroupConnection

  """
  The preferred language used by this account
  """
  language: String

  """
  The last name of the person this account represents, if known
  """
  lastName: String

  """
  Arbitrary additional metadata about this account
  """
  metafields: [Metafield]

  """
  The full name of the person this account represents, if known
  """
  name: String

  """
  Some note about this account
  """
  note: String

  """
  URL of picture to display on profile
  """
  picture: String

  """
  An object storing plugin-specific preferences for this account
  """
  preferences: JSONObject

  """
  The primary email address for the account. This matches the address in `emailRecords` where `provides` is `default`.
  """
  primaryEmailAddress: Email!

  """
  The date and time at which this account was last updated
  """
  updatedAt: DateTime

  """
  The Identity user ID with which this account is associated
  """
  userId: String!

  """
  Username
  """
  username: String
}

"""
Wraps a list of `Accounts`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type AccountConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [AccountEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Account]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is an `Account` object
"""
type AccountEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The account
  """
  node: Account
}

"""
The fields by which you are allowed to sort any query that returns an `AccountConnection`
"""
enum AccountSortByField {
  """
  Account ID
  """
  _id

  """
  Date and time at which this account was created
  """
  createdAt

  """
  Date and time at which this account was last updated
  """
  updatedAt
}

"""
Defines a new Address and the account to which it should be added
"""
input AddAccountAddressBookEntryInput {
  """
  The account ID
  """
  accountId: ID!

  """
  The address to add
  """
  address: AddressInput!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
The response from the `addAccountAddressBookEntry` mutation
"""
type AddAccountAddressBookEntryPayload {
  """
  The added address
  """
  address: Address

  """
  The added address edge
  """
  addressEdge: AddressEdge

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Defines a new Email and the account to which it should be added
"""
input AddAccountEmailRecordInput {
  """
  The account ID, which defaults to the viewer account
  """
  accountId: ID

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address to add
  """
  email: Email!
}

"""
The response from the `addAccountEmailRecord` mutation
"""
type AddAccountEmailRecordPayload {
  """
  The account, with updated `emailRecords`
  """
  account: Account

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Defines a group and account that should be linked
"""
input AddAccountToGroupInput {
  """
  The account ID
  """
  accountId: ID!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group ID
  """
  groupId: ID!
}

"""
The response from the `addAccountToGroup` mutation
"""
type AddAccountToGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated group
  """
  group: Group
}

"""
Input for the `addCartItems` mutation
"""
input AddCartItemsInput {
  """
  The cart ID
  """
  cartId: ID!

  """
  If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Array of items to be added to the cart
  """
  items: [CartItemInput]!
}

"""
The payload returned from the `addCartItems` mutation call
"""
type AddCartItemsPayload {
  """
  The modified cart. You should check `incorrectPriceFailures` and `minOrderQuantityFailures` for
  information necessary to display errors to the shopper. Some items may not have been added.
  """
  cart: Cart

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Clients should check to see if any items failed to be added due to the price not matching the current price.
  In general, a user interface should display the correct current prices to the shopper, confirm that they still
  want to add the items, and then call `createCart` or `addCartItems` to do so.

  Note that this field will always exist but may be an empty array if there were no failures of this type.
  """
  incorrectPriceFailures: [IncorrectPriceFailureDetails]!

  """
  Clients should check to see if any items failed to be added due to quantity being below the minimum order
  quantity defined for the product variant. In general, a user interface should display the minimum order
  quantity to the shopper and allow them to add that quantity or greater.

  Note that this field will always exist but may be an empty array if there were no failures of this type.
  """
  minOrderQuantityFailures: [MinOrderQuantityFailureDetails]!
}

"""
Input for the addOrderFulfillmentGroup mutation
"""
input AddOrderFulfillmentGroupInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The order fulfillment group input, used to build the new group
  """
  fulfillmentGroup: OrderFulfillmentGroupExistingOrderInput!

  """
  Optional list of order item IDs that should be moved from an existing group to the new group
  """
  moveItemIds: [ID]

  """
  ID of the order that has the item you want to add the group to
  """
  orderId: ID!
}

"""
Response payload for the addOrderFulfillmentGroup mutation
"""
type AddOrderFulfillmentGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  ID of the added fulfillment group
  """
  newFulfillmentGroupId: ID!

  """
  The updated order
  """
  order: Order!
}

"""
Input for `addTag` mutation
"""
input AddTagInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Title to display to customers
  """
  displayTitle: String

  """
  Hero media URL
  """
  heroMediaUrl: String

  """
  Whether the tag is visible
  """
  isVisible: Boolean!

  """
  Tag metafields
  """
  metafields: [MetafieldInput]

  """
  Unique name of the tag
  """
  name: String!

  """
  The shop that owns the tag
  """
  shopId: ID!

  """
  The tag slug. If left blank, the name will be slugified and saved as the slug
  """
  slug: String
}

"""
Response payload for `addTag` mutation
"""
type AddTagPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The shop that owns the tag
  """
  shopId: ID!

  """
  The newly-created tag
  """
  tag: Tag!
}

"""
Represents a physical or mailing address somewhere on Earth
"""
type Address {
  """
  The address ID
  """
  _id: ID

  """
  The street address / first line
  """
  address1: String!

  """
  Optional second line
  """
  address2: String

  """
  City
  """
  city: String!

  """
  Optional company name, if it's a business address
  """
  company: String

  """
  Country
  """
  country: String!

  """
  The first name of a person at this address
  This is an optional field to support legacy and third party platforms
  We use fullName internally, and use first and last name fields to combine into a full name if needed
  """
  firstName: String

  """
  The full name of a person at this address
  """
  fullName: String!

  """
  Is this the default address for billing purposes?
  """
  isBillingDefault: Boolean

  """
  Is this a commercial address?
  """
  isCommercial: Boolean!

  """
  Is this the default address to use when selecting a shipping address at checkout?
  """
  isShippingDefault: Boolean

  """
  The last name of a person at this address
  This is an optional field to support legacy and third party platforms
  We use fullName internally, and use first and last name fields to combine into a full name if needed
  """
  lastName: String

  """
  Arbitrary additional metadata about this address
  """
  metafields: [Metafield]

  """
  A phone number for someone at this address
  """
  phone: String!

  """
  Postal code
  """
  postal: String!

  """
  Region. For example, a U.S. state
  """
  region: String!
}

"""
Wraps a list of `Addresses`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type AddressConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [AddressEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Address]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is an `Address` object
"""
type AddressEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The address
  """
  node: Address
}

"""
The details of an `Address` to be created or updated
"""
input AddressInput {
  """
  The street address / first line
  """
  address1: String!

  """
  Optional second line
  """
  address2: String

  """
  Optionally, a name for this address (e.g. 'Home') to easily identify it in the future
  """
  addressName: String

  """
  City
  """
  city: String!

  """
  Optional company name, if it's a business address
  """
  company: String

  """
  Country
  """
  country: String!

  """
  The first name of a person at this address
  This is an optional field to support legacy and third party platforms
  We use fullName internally, and use first and last name fields to combine into a full name if needed
  """
  firstName: String

  """
  The full name of a person at this address
  """
  fullName: String!

  """
  Is this the default address for billing purposes?
  """
  isBillingDefault: Boolean

  """
  Is this a commercial address?
  """
  isCommercial: Boolean

  """
  Is this the default address to use when selecting a shipping address at checkout?
  """
  isShippingDefault: Boolean

  """
  The last name of a person at this address
  This is an optional field to support legacy and third party platforms
  We use fullName internally, and use first and last name fields to combine into a full name if needed
  """
  lastName: String

  """
  Arbitrary additional metadata about this address
  """
  metafields: [MetafieldInput]

  """
  A phone number for someone at this address
  """
  phone: String!

  """
  Postal code
  """
  postal: String!

  """
  Region. For example, a U.S. state
  """
  region: String!
}

"""
A list of the possible types of `Address`
"""
enum AddressType {
  """
  Address can be used for payment transactions and invoicing
  """
  billing

  """
  Address can be used as a mailing address for sending physical items
  """
  shipping
}

"""
Details about an error that was the result of validating an address that is invalid
"""
type AddressValidationError {
  """
  A longer, detailed error message suitable for showing in the user interface
  """
  details: String

  """
  An identifier of the source of this error. These are not currently standardized. As long as your client understands it, any string is fine.
  """
  source: String

  """
  A short error message suitable for showing in the user interface
  """
  summary: String!

  """
  The error type. These are not currently standardized. As long as your client understands it, any string is fine.
  """
  type: String!
}

"""
The response from `Query.addressValidation`
"""
type AddressValidationResults {
  """
  A list of suggested addresses. If the address is valid as is OR the address input is invalid OR
  the shop is not configured to validate addresses, then this will be empty.
  """
  suggestedAddresses: [SuggestedAddress]!

  """
  This may have information about the ways in which the provided address input is incomplete or invalid.
  Show these errors in the address review user interface.
  """
  validationErrors: [AddressValidationError]!
}

"""
An address validation rule specifies which validation services should run for
which countries in each shop.
"""
type AddressValidationRule implements Node {
  """
  The rule ID
  """
  _id: ID!

  """
  Country codes for which this service is enabled
  """
  countryCodes: [String]

  """
  The date and time at which this rule was created
  """
  createdAt: DateTime!

  """
  The name of one of the installed validation services. Use `addressValidationServices`
  query to get a list with more details about all installed services.
  """
  serviceName: String!

  """
  ID of the shop to which this rule applies
  """
  shopId: ID!

  """
  The date and time at which this rule was last updated
  """
  updatedAt: DateTime!
}

"""
Wraps a list of `AddressValidationRules`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type AddressValidationRuleConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [AddressValidationRuleEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [AddressValidationRule]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `AddressValidationRule` object
"""
type AddressValidationRuleEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The address validation rule
  """
  node: AddressValidationRule
}

"""
The fields by which you are allowed to sort any query that returns an `AddressValidationRuleConnection`
"""
enum AddressValidationRuleSortByField {
  """
  AddressValidationRule ID
  """
  _id

  """
  Date and time at which the rule was created
  """
  createdAt

  """
  Service name
  """
  serviceName

  """
  Date and time at which the rule was last updated
  """
  updatedAt
}

"""
A single registered address validation service
"""
type AddressValidationService {
  """
  Human-readable name to show operators
  """
  displayName: String!

  """
  Unique name to serve as a key identifying this service
  """
  name: String!

  """
  An optional list of all country codes that this address service supports. Null means all countries.
  """
  supportedCountryCodes: [String]
}

"""
Defines a surcharge that has been applied to a Cart or Order
"""
type AppliedSurcharge implements Node {
  """
  The surcharge ID
  """
  _id: ID!

  """
  The amount of the surcharge
  """
  amount: Money!

  """
  The fulfillmentGroupId (for reference)
  """
  fulfillmentGroupId: ID

  """
  The message to explain the surchage to customers, translated (if available) based on shop language
  """
  message(
    """
    The language in which you want the message. If no translation is available for this language,
    it will be in the default language of the related shop.
    """
    language: String!
  ): String

  """
  The surchargeId from the surchages collection (for reference)
  """
  surchargeDefinitionId: ID!
}

"""
Input for an `ApplyDiscountCodeToCartInput`
"""
input ApplyDiscountCodeToCartInput {
  """
  Cart to add discount to
  """
  cartId: ID!

  """
  Discount code to add to cart
  """
  discountCode: String!

  """
  Shop cart belongs to
  """
  shopId: ID!

  """
  Cart token, if anonymous
  """
  token: String
}

"""
Response from the `applyDiscountCodeToCart` mutation
"""
type ApplyDiscountCodeToCartPayload {
  """
  The updated cart with discount code applied
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the `approveOrderPayments` mutation
"""
input ApproveOrderPaymentsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The order ID
  """
  orderId: ID!

  """
  The IDs of one or more payments to approve for this order
  """
  paymentIds: [ID]!

  """
  The ID of the shop that owns this order
  """
  shopId: ID!
}

"""
Response from the `approveOrderPayments` mutation
"""
type ApproveOrderPaymentsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Input for the archiveMediaRecord mutation
"""
input ArchiveMediaRecordInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of MediaRecord to archive
  """
  mediaRecordId: ID!

  """
  ID of shop that owns this MediaRecord
  """
  shopId: ID!
}

"""
Response payload for the archiveMediaRecord mutation
"""
type ArchiveMediaRecordPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The archived MediaRecord
  """
  mediaRecord: MediaRecord!
}

"""
Input for the `archiveProducts` mutation
"""
input ArchiveProductVariantsInput {
  """
  ID of shop that owns all variants you are archiving
  """
  shopId: ID!

  """
  Array of IDs of variants to archive
  """
  variantIds: [ID]!
}

"""
Response payload of `archiveProductVariants` mutation
"""
type ArchiveProductVariantsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Array of newly archived variants
  """
  variants: [ProductVariant]!
}

"""
Input for the `archiveProducts` mutation
"""
input ArchiveProductsInput {
  """
  Array of IDs of products to archive
  """
  productIds: [ID]!

  """
  ID of shop that owns all products you are archiving
  """
  shopId: ID!
}

"""
Response payload of `archiveProducts` mutation
"""
type ArchiveProductsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Array of newly archived products
  """
  products: [Product]!
}

"""
An attribute restriction condition
"""
type AttributeRestrictions {
  """
  The operator to use for value comparison
  """
  operator: String!

  """
  The property to check
  """
  property: String!

  """
  The type of this property
  """
  propertyType: String!

  """
  The value to check for
  """
  value: String!
}

"""
Input to create an attribute restriction condition
"""
input AttributeRestrictionsInput {
  """
  The operator to use for value comparison
  """
  operator: String!

  """
  The property to check
  """
  property: String!

  """
  The type of this property
  """
  propertyType: String!

  """
  The value to check for
  """
  value: String!
}

input AuthenticateParamsInput {
  access_token: String
  access_token_secret: String
  code: String
  password: String
  provider: String
  token: String
  user: UserInput
}

"""
Represents a single user partial account
"""
type BasicAccount implements Node {
  """
  The account ID
  """
  _id: ID!

  """
  Flag to indicate if the account accepts marketing emails
  """
  acceptsMarketing: Boolean

  """
  List of shop Ids
  """
  adminUIShopIds: [String]

  """
  The date and time at which this account was created
  """
  createdAt: DateTime

  """
  Email record associated with the account
  """
  emails: [EmailRecord]

  """
  List of group Ids to which the account belongs
  """
  groups: [String]

  """
  The full name of the person this account represents, if known
  """
  name: String

  """
  List of shipping/billing addresses
  """
  profile: [Profile]

  """
  ID of shop
  """
  shopId: String

  """
  Account creation state
  """
  state: String

  """
  The date and time at which this account was last updated
  """
  updatedAt: DateTime

  """
  ID of user
  """
  userId: String
}

"""
A single calculated tax for a cart, order group, cart item, or order item
"""
type CalculatedTax {
  """
  Calculated tax ID
  """
  _id: ID!

  """
  Jurisdiction ID. It is up to the tax service to determine if and how to use this.
  """
  jurisdictionId: String

  """
  Did this tax match due to the order origin or the order destination?
  """
  sourcing: TaxSource!

  """
  Amount of tax due
  """
  tax: Money!

  """
  A human-readable display name for showing this tax to operators and customers in the UI
  """
  taxName: String!

  """
  The tax rate used for this calculation
  """
  taxRate: Rate!

  """
  Amount that was used for calculating the tax due
  """
  taxableAmount: Money!
}

"""
Input for the cancelOrderItem mutation
"""
input CancelOrderItemInput {
  """
  Quantity to cancel. Must be equal to or less than the item quantity.
  """
  cancelQuantity: Int!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of the item order you want to cancel
  """
  itemId: ID!

  """
  ID of the order that has the item you want to cancel
  """
  orderId: ID!

  """
  An optional free text reason for cancellation, which may be shown to operators
  or to the user who placed the order.
  """
  reason: String
}

"""
Response payload for the cancelOrderItem mutation
"""
type CancelOrderItemPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Input for the `captureOrderPayments` mutation
"""
input CaptureOrderPaymentsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The order ID
  """
  orderId: ID!

  """
  The IDs of one or more payments to capture for this order
  """
  paymentIds: [ID]!

  """
  The ID of the shop that owns this order
  """
  shopId: ID!
}

"""
Response from the `captureOrderPayments` mutation
"""
type CaptureOrderPaymentsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
The cart holds selected items until order is placed.
"""
type Cart implements Node {
  """
  The Cart ID
  """
  _id: ID!

  """
  The account that owns the cart. Some carts are created for anonymous users. Anonymous carts have a null account.
  Every account has exactly one cart per shop.
  """
  account: Account

  """
  Holds all information collected for a cart during checkout
  """
  checkout: Checkout

  """
  The date and time at which the cart was created, which is when the first item was added to it.
  """
  createdAt: DateTime!

  """
  An email address that has been associated with the cart
  """
  email: String

  """
  The date and time at which the cart will expire. Account carts usually do not expire, so they will have a null value here.
  """
  expiresAt: DateTime

  """
  The items that have been added to the cart. A cart is not created until the first item is added. Items can be removed from a cart, and a cart is not deleted if all items are removed from it. Because all items may have been removed, this may be an empty array.
  """
  items(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, items are sorted by when they were added to the cart, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: CartItemsSortByField = addedAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): CartItemConnection

  """
  If any products or variants become hidden or are deleted after they were added to this cart, they'll be
  automatically moved from `items` to `missingItems`. Clients may want to use this to show an
  "items that are no longer available" list to storefront users.

  If a product becomes visible again, the item will never be automatically moved from `missingItems`
  back to `items`, but clients may want to provide a way for users to manually do this.
  """
  missingItems: [CartItem]

  """
  If you integrate with third-party systems that require you to send the same ID for order
  calculations as for cart calculations, you may use this ID, which is the same on a `cart` as on
  the `order` placed from that cart. This ID can also be customized by plugins and is the best
  ID to use if it is necessary to show a cart ID in the user interface.
  """
  referenceId: String

  """
  The shop that owns the cart.
  """
  shop: Shop!

  """
  Surcharges applied to this cart
  """
  surcharges: [AppliedSurcharge]!

  """
  A summary of calculated taxes for this cart. Null means "not able to calculate",
  such as when no fulfillment method has been selected for some fulfillment groups.
  """
  taxSummary: TaxSummary

  """
  Total quantity of all items in the cart
  """
  totalItemQuantity: Int!

  """
  The date and time at which this cart was last updated.
  """
  updatedAt: DateTime!
}

"""
A single item in a cart. The item contains information about an intended purchase.
"""
type CartItem implements Node {
  """
  The cart item ID
  """
  _id: ID!

  """
  "
  The date and time at which this item was first added to the associated cart.
  If an item is added, removed, and then added again, this will reflect the most recent addition.
  However, if an item is added twice, the quantity will increase but this date will remain
  the initial added date.
  """
  addedAt: DateTime!

  """
  FUTURE. Additional attributes of the chosen item. For example, if this item is for a product, socks, where `blue` and `small`
  options were chosen for some configurable attributes, then `color:blue` and `size:small` will be indicated here.
  """
  attributes: [CartItemAttribute]

  """
  The current comparison (e.g., MSRP) price of the item
  """
  compareAtPrice: Money

  """
  The date and time at which the cart item was created. If an item is added, removed, and then added again,
  the original item is destroyed and this field will reflect the time it was created for the most recent addition.
  """
  createdAt: DateTime!

  """
  The URLs for a picture of the item in various sizes
  """
  imageURLs: ImageSizes

  """
  The quantity of this item currently available to sell.
  This number is updated when an order is placed by the customer.
  This number does not include reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  This is most likely the quantity to display in the storefront UI.
  """
  inventoryAvailableToSell: Int

  """
  True if this item is currently sold out but allows backorders. A storefront UI may use this
  to decide to show a "Backordered" indicator.
  """
  isBackorder: Boolean!

  """
  True if this item has a low available quantity (`inventoryAvailableToSell`) in stock.
  A storefront UI may use this to decide to show a "Low Quantity" indicator.
  """
  isLowQuantity: Boolean!

  """
  True if this item is currently sold out (`inventoryAvailableToSell` is 0). A storefront
  UI may use this to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  """
  isSoldOut: Boolean!

  """
  Is this a taxable item?
  """
  isTaxable: Boolean!

  """
  Arbitrary additional metadata about this cart item.
  """
  metafields: [Metafield]

  """
  The selected variant optionTitle
  """
  optionTitle: String

  """
  Packing information such as item weight, height, length, and depth. Used for calculating shipping rates.
  """
  parcel: ShippingParcel

  """
  The current price of the item
  """
  price: Money!

  """
  The price at which this item was listed when it was added to the cart
  """
  priceWhenAdded: Money!

  """
  The product and chosen options
  """
  productConfiguration: ProductConfiguration!

  """
  The product's slug
  """
  productSlug: String

  """
  The list of tags that have been applied to this product
  """
  productTags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = _id

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  The type of product, used to display cart items differently
  """
  productType: String

  """
  The product vendor
  """
  productVendor: String

  """
  The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item.
  """
  quantity: Int!

  """
  The shop associated with this cart item.
  """
  shop: Shop!

  """
  The current price of the item multiplied by the quantity
  """
  subtotal: Money!

  """
  Total tax calculated for this item
  """
  tax: Money

  """
  The tax code for this item
  """
  taxCode: String

  """
  Amount of subtotal that is taxable
  """
  taxableAmount: Money

  """
  List of calculated taxes due for this item
  """
  taxes: [CalculatedTax]

  """
  A title for use in cart/orders that conveys the selected product's title + chosen options
  """
  title: String!

  """
  The date and time at which this item was last updated
  """
  updatedAt: DateTime!

  """
  The selected variant title
  """
  variantTitle: String
}

"""
One attribute of a cart item
"""
type CartItemAttribute {
  """
  The attribute label, e.g., Color
  """
  label: String

  """
  The attribute value, e.g., Blue
  """
  value: String
}

"""
Wraps a list of `CartItem`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type CartItemConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [CartItemEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [CartItem]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `CartItem` object
"""
type CartItemEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The cart item
  """
  node: CartItem
}

"""
Information about an item to add to a cart
"""
input CartItemInput {
  """
  Arbitrary additional metadata about this cart item.
  """
  metafields: [MetafieldInput]

  """
  The price of this item, for validating that this matches the actual price in the system,
  in case the client has stale data.
  """
  price: MoneyInput!

  """
  The product and chosen options
  """
  productConfiguration: ProductConfigurationInput!

  """
  The number of this item to add to the cart
  """
  quantity: Int!
}

"""
Allowed values for cart item sortBy parameter
"""
enum CartItemsSortByField {
  """
  Cart item ID
  """
  _id

  """
  Date and time at which the item was added to the cart
  """
  addedAt
}

"""
Supported cart reconciliation modes
"""
enum CartReconciliationMode {
  """
  Delete the anonymous cart and use the account cart.
  """
  keepAccountCart

  """
  Assign the anonymous cart to the account, and delete the account cart.
  """
  keepAnonymousCart

  """
  Move all items from the anonymous cart into the account cart along with existing
  account cart items. If the same item is in both carts, combine the quantities.
  """
  merge
}

"""
A summary of the totals for this cart
"""
type CartSummary {
  """
  The total of all discounts applied, as a positive number
  """
  discountTotal: Money!

  """
  The calculated tax-exclusive tax rate on all items and fulfillment prices (taxTotal / taxableAmount).
  This may be null, and there is a difference between null and 0. Null means `not able to calculate`,
  such as when no fulfillment method has been selected for some fulfillment groups.
  """
  effectiveTaxRate: Rate

  """
  The total price of all chosen fulfillment methods. This may be null, and there is a difference
  between null and 0. Null means `not able to calculate`, such as when no fulfillment method has
  been selected for some fulfillment groups.
  """
  fulfillmentTotal: Money

  """
  The combined prices of all cart items
  """
  itemTotal: Money!

  """
  The combined total of all surcharges. This may be null, and there is a difference
  between null and 0. Null means `not able to calculate`, such as when no fulfillment method has
  been selected for some fulfillment groups.
  """
  surchargeTotal: Money

  """
  The total estimated tax that has not already been included in the item prices. This may be null,
  and there is a difference between null and 0. Null means `not able to calculate`, such as when no
  fulfillment methods have been selected or there is some other issue with the tax service.
  """
  taxTotal: Money

  """
  The total amount that was deemed taxable by the tax service
  """
  taxableAmount: Money!

  """
  The sum of `itemTotal`, `fulfillmentTotal`, and `taxTotal`, minus `discountTotal`
  """
  total: Money!
}

"""
One product catalog for a particular shop
"""
type Catalog implements Node {
  """
  The Catalog ID
  """
  _id: ID!

  """
  The date and time at which this Catalog was first created
  """
  createdAt: DateTime!

  """
  The shop to which this catalog belongs
  """
  shop: Shop!

  """
  The date and time at which this Catalog was last updated
  """
  updatedAt: DateTime!
}

"""
A filter to be applied to a Catalog query
"""
input CatalogBooleanFilter {
  """
  The name of the filter
  """
  name: CatalogBooleanFilterName!

  """
  The filter value
  """
  value: Boolean!
}

"""
The list of currently supported top level Catalog props on which catalog items can be filtered.
"""
enum CatalogBooleanFilterName {
  """
  isBackorder
  """
  isBackorder

  """
  isDeleted
  """
  isDeleted

  """
  isLowQuantity
  """
  isLowQuantity

  """
  isSoldOut
  """
  isSoldOut

  """
  isVisible
  """
  isVisible
}

"""
Catalog items are combined to create a catalog. Each item can represent a different type of content.
"""
interface CatalogItem {
  """
  Item ID
  """
  _id: ID!

  """
  Date and time at which the item was created
  """
  createdAt: DateTime

  """
  Shop that owns the item
  """
  shop: Shop!

  """
  Date and time at which the item was last updated
  """
  updatedAt: DateTime
}

"""
Wraps a list of `CatalogItem`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type CatalogItemConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [CatalogItemEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [CatalogItem]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
Represents a catalog item that displays some non-product content
"""
type CatalogItemContent implements CatalogItem & Node {
  """
  The CatalogItemProduct ID
  """
  _id: ID!

  """
  The date and time at which this CatalogItem was first created
  """
  createdAt: DateTime!

  """
  The shop to which this catalog belongs
  """
  shop: Shop!

  """
  The date and time at which this CatalogItem was last updated
  """
  updatedAt: DateTime!
}

"""
A connection edge in which each node is a `CatalogItem` object
"""
type CatalogItemEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The catalog item
  """
  node: CatalogItem
}

"""
Represents a catalog item that displays a product
"""
type CatalogItemProduct implements CatalogItem & Node {
  """
  The CatalogItemProduct ID
  """
  _id: ID!

  """
  The date and time at which this CatalogItem was first created, which is when the related product was first published
  """
  createdAt: DateTime!

  """
  The catalog product
  """
  product: CatalogProduct

  """
  The shop to which this catalog belongs
  """
  shop: Shop!

  """
  The date and time at which this CatalogItem was last updated, which is when the related product was most recently published
  """
  updatedAt: DateTime!
}

"""
Allowed values for sorting catalog items
"""
enum CatalogItemSortByField {
  """
  Sort by item ID
  """
  _id

  """
  Sort by date and time at which the item was created
  """
  createdAt

  """
  Sort in the shop-defined order for the tag filter
  """
  featured

  """
  Sort by price
  """
  minPrice

  """
  Sort by date and time at which the item was last updated
  """
  updatedAt
}

"""
Represents a product that has been published into a shop catalog. The related `Product` is the source of truth for
shop administrators, but that is then published to a catalog as a `CatalogProduct`, which is what should
be displayed to shoppers who browse that catalog.
"""
type CatalogProduct implements CatalogProductOrVariant & Node {
  """
  The CatalogProduct ID. Do not assume that this is the same as the related product ID. See `productId` for that.
  """
  _id: ID!

  """
  The product barcode value, if it has one
  """
  barcode: String

  """
  The date and time at which this CatalogProduct was created, which is when the related product was first published
  """
  createdAt: DateTime!

  """
  The full product description, which may have newline characters in it
  """
  description: String

  """
  The height of the product, if it has physical dimensions
  """
  height: Float

  """
  True if every purchasable variant of this product is sold out but allows backorders. A storefront UI may use this
  to decide to show a "Backordered" indicator.
  """
  isBackorder: Boolean!

  """
  True if this product has been deleted. Typically, deleted products are not returned in queries.
  """
  isDeleted: Boolean!

  """
  True if at least one purchasable variant of this product has a low quantity in stock. A storefront UI may use this
  to decide to show a "Low Quantity" indicator.
  """
  isLowQuantity: Boolean!

  """
  True if every purchasable variant of this product is sold out. A storefront UI may use this
  to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  """
  isSoldOut: Boolean!

  """
  True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  """
  isVisible: Boolean!

  """
  The length of the product, if it has physical dimensions
  """
  length: Float

  """
  All media for this product and its variants
  """
  media: [ImageInfo]

  """
  The product description to use for page `description` meta element in HTML
  """
  metaDescription: String

  """
  Arbitrary additional metadata about this product
  """
  metafields: [Metafield]

  """
  The minimum quantity that must be added to a cart
  """
  minOrderQuantity: Int

  """
  The country of origin
  """
  originCountry: String

  """
  Subtitle
  """
  pageTitle: String

  """
  Dimensions and other information about the containers in which this product will be shipped
  """
  parcel: ShippingParcel

  """
  Price and related information, per currency
  """
  pricing: [ProductPricingInfo]!

  """
  The primary image
  """
  primaryImage: ImageInfo

  """
  The related Product ID
  """
  productId: ID!

  """
  An arbitrary product type value, such as from an external system
  """
  productType: String

  """
  The shop to which this product belongs
  """
  shop: Shop!

  """
  A stock keeping unit (SKU) identifier for this product
  """
  sku: String

  """
  A URL-safe and human-readable string that uniquely identifies this product
  """
  slug: String

  """
  Holds metadata specific to a specific social network service
  """
  socialMetadata: [SocialMetadata]

  """
  When a shopper purchases this product, what types of fulfillment can they choose from?
  """
  supportedFulfillmentTypes: [FulfillmentType]!

  """
  The list of tag IDs that have been applied to this product
  """
  tagIds: [ID]

  """
  The list of tags that have been applied to this product
  """
  tags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = _id

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  Product title
  """
  title: String

  """
  The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  """
  updatedAt: DateTime!

  """
  A flat list of all variants for this product
  """
  variants: [CatalogProductVariant]

  """
  The product vendor or manufacturer, for display
  """
  vendor: String

  """
  The weight of the product on Earth, if it has physical dimensions
  """
  weight: Float

  """
  The width of the product, if it has physical dimensions
  """
  width: Float
}

"""
This interface represents the fields that are identical for both Products and Variants
"""
interface CatalogProductOrVariant {
  """
  The product barcode value, if it has one
  """
  barcode: String

  """
  The date and time at which this CatalogProduct was created, which is when the related product was first published
  """
  createdAt: DateTime

  """
  The height of the product, if it has physical dimensions
  """
  height: Float

  """
  The length of the product, if it has physical dimensions
  """
  length: Float

  """
  Arbitrary additional metadata about this product
  """
  metafields: [Metafield]

  """
  The minimum quantity that must be added to a cart
  """
  minOrderQuantity: Int

  """
  The country of origin
  """
  originCountry: String

  """
  The shop to which this product belongs
  """
  shop: Shop!

  """
  A stock keeping unit (SKU) identifier for this product
  """
  sku: String

  """
  Product or variant title
  """
  title: String

  """
  The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  """
  updatedAt: DateTime

  """
  The weight of the product on Earth, if it has physical dimensions
  """
  weight: Float

  """
  The width of the product, if it has physical dimensions
  """
  width: Float
}

"""
A variant of a catalog product
"""
type CatalogProductVariant implements CatalogProductOrVariant & Node {
  """
  The CatalogProductVariant ID. Do not assume that this is the same as the related variant ID. See `variantId` for that.
  """
  _id: ID!

  """
  The attribute label describes the category of variant, for example, `Color` or `Size`.
  In most cases this will be the same for all variants at the same level.
  """
  attributeLabel: String!

  """
  The product variant barcode value, if it has one
  """
  barcode: String

  """
  True for a purchasable variant if an order containing this variant will be accepted even when there is insufficient
  available inventory (`inventoryAvailableToSell`) to fulfill it immediately. For non-purchasable variants, this is true if at least one purchasable
  child variant can be backordered. A storefront UI may use this in combination with `inventoryAvailableToSell` to
  decide whether to show or enable an "Add to Cart" button.
  """
  canBackorder: Boolean!

  """
  The date and time at which this CatalogProductVariant was created, which is when the related product was first published
  """
  createdAt: DateTime

  """
  The height of the product variant, if it has physical dimensions
  """
  height: Float

  """
  The position of this variant among other variants at the same level of the product-variant-option hierarchy
  """
  index: Int!

  """
  The quantity of this item currently available to sell.
  This number is updated when an order is placed by the customer.
  This number does not include reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  If this is a variant, this number is created by summing all child option inventory numbers.
  This is most likely the quantity to display in the storefront UI.
  """
  inventoryAvailableToSell: Int

  """
  The quantity of this item currently in stock.
  This number is updated when an order is processed by the operator.
  This number includes all inventory, including reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  If this is a variant, this number is created by summing all child option inventory numbers.
  This is most likely just used as a reference in the operator UI, and not displayed in the storefront UI.
  """
  inventoryInStock: Int

  """
  True for a purchasable variant if it is sold out but allows backorders. For non-purchasable variants, this is
  true if every purchasable child variant is sold out but allows backorders. A storefront UI may use this
  to decide to show a "Backordered" indicator.
  """
  isBackorder: Boolean!

  """
  True for a purchasable variant if it has a low available quantity (`inventoryAvailableToSell`) in stock.
  For non-purchasable variants, this is true if at least one purchasable child variant has a low available
  quantity in stock. A storefront UI may use this to decide to show a "Low Quantity" indicator.
  """
  isLowQuantity: Boolean!

  """
  True for a purchasable variant if it is sold out (`inventoryAvailableToSell` is 0). For non-purchasable
  variants, this is true if every purchasable child variant is sold out. A storefront UI may use this
  to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  """
  isSoldOut: Boolean!

  """
  Is sales tax charged on this item?
  """
  isTaxable: Boolean!

  """
  The length of the product, if it has physical dimensions
  """
  length: Float

  """
  All media for this variant / option
  """
  media: [ImageInfo]

  """
  Arbitrary additional metadata about this product
  """
  metafields: [Metafield]

  """
  The minimum quantity that must be added to a cart
  """
  minOrderQuantity: Int

  """
  A short title to use for product detail select lists
  """
  optionTitle: String

  """
  Child variants, if any
  """
  options: [CatalogProductVariant]

  """
  The country of origin
  """
  originCountry: String

  """
  Price and related information, per currency
  """
  pricing: [ProductPricingInfo]!

  """
  The primary image of this variant / option
  """
  primaryImage: ImageInfo

  """
  The shop to which this product variant belongs
  """
  shop: Shop!

  """
  A stock keeping unit (SKU) identifier for this product
  """
  sku: String

  """
  An optional code which, if understood by the active tax service for the shop, determines how this product should be taxed
  """
  taxCode: String

  """
  A description to use for the tax line item on an invoice
  """
  taxDescription: String

  """
  The full variant title for use on cart, checkout, and order summaries and on invoices.
  This fully describes the configured variant. For example, if this is an option with
  `optionTitle` `Large`, its parent variant has `optionTitle` `Red`, and the product
  `title` is `Fancy T-Shirt`, then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  """
  title: String

  """
  The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  """
  updatedAt: DateTime

  """
  The related Variant ID
  """
  variantId: ID!

  """
  The weight of the product on Earth, if it has physical dimensions
  """
  weight: Float

  """
  The width of the product, if it has physical dimensions
  """
  width: Float
}

"""
Holds all information collected for a cart during checkout
"""
type Checkout {
  """
  One or more fulfillment groups, for example, mapping certain items to certain shipping addresses
  """
  fulfillmentGroups: [FulfillmentGroup]!

  """
  A summary of the totals for this cart
  """
  summary: CartSummary!
}

"""
Input for the `cloneProductVariants` mutation
"""
input CloneProductVariantsInput {
  """
  ID of shop that owns all product variants you want to clone
  """
  shopId: ID!

  """
  Array of IDs of variants to clone
  """
  variantIds: [ID]!
}

"""
Response payload of `cloneProductVariants` mutation
"""
type CloneProductVariantsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Array of newly cloned product variants
  """
  variants: [ProductVariant]!
}

"""
Input for the `cloneProducts` mutation
"""
input CloneProductsInput {
  """
  Array of IDs of products to clone
  """
  productIds: [ID]!

  """
  ID of shop that owns all products you are cloning
  """
  shopId: ID!
}

"""
Response payload of `cloneProducts` mutation
"""
type CloneProductsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Array of newly cloned products
  """
  products: [Product]!
}

"\nAn opaque string that identifies a particular result within a connection,\nallowing you to request a subset of results before or after that result.\n"
scalar ConnectionCursor

"\nAn integer between 1 and 50, inclusive. Values less than 1 become 1 and\nvalues greater than 50 become 50.\n"
scalar ConnectionLimitInt

"""
The details for creating a group
"""
input CreateAccountGroupInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group to create
  """
  group: GroupInput!

  """
  The ID of the shop this group belongs to
  """
  shopId: ID
}

"""
The response from the `createAccountGroup` mutation
"""
type CreateAccountGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The new group
  """
  group: Group
}

"""
Defines the account which should be created
"""
input CreateAccountInput {
  """
  Bio to display on profile
  """
  bio: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Email record to create account with
  """
  emails: [EmailRecordInput]!

  """
  Name to display on profile
  """
  name: String

  """
  URL of picture to display on profile
  """
  picture: String

  """
  The ID of the shop this account will belong to
  """
  shopId: ID!

  """
  The userID account was created from create a new account from
  """
  userId: ID!

  """
  Username
  """
  username: String
}

"""
The response from the `createAccount` mutation
"""
type CreateAccountPayload {
  """
  The added account
  """
  account: BasicAccount

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the `createAddressValidationRule` mutation
"""
input CreateAddressValidationRuleInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Country codes for which this service is enabled. `null` means all, while an empty array means none.
  """
  countryCodes: [String]

  """
  The name of one of the installed validation services. Use `addressValidationServices`
  query to get a list, and then use the `name` field value from one of them.
  """
  serviceName: String!

  """
  ID of the shop to which this rule applies
  """
  shopId: ID!
}

"""
Payload for the `createAddressValidationRule` mutation
"""
type CreateAddressValidationRulePayload {
  """
  Created address validation rule
  """
  addressValidationRule: AddressValidationRule!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
The input necessary to create a cart
"""
input CreateCartInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Array of items to add to new cart.
  """
  items: [CartItemInput]!

  """
  ShopId association for the cart.
  """
  shopId: ID!
}

"""
The payload returned from the `createCart` mutation call
"""
type CreateCartPayload {
  """
  The created cart, if at least one item could be added. Otherwise null, and you should check
  `incorrectPriceFailures` and `minOrderQuantityFailures` for information necessary to display
  errors to the shopper.
  """
  cart: Cart

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Clients should check to see if any items failed to be added due to the price not matching the current price.
  In general, a user interface should display the correct current prices to the shopper, confirm that they still
  want to add the items, and then call `createCart` or `addCartItems` to do so.

  Note that this field will always exist but may be an empty array if there were no failures of this type.
  """
  incorrectPriceFailures: [IncorrectPriceFailureDetails]!

  """
  Clients should check to see if any items failed to be added due to quantity being below the minimum order
  quantity defined for the product variant. In general, a user interface should display the minimum order
  quantity to the shopper and allow them to add that quantity or greater.

  Note that this field will always exist but may be an empty array if there were no failures of this type.
  """
  minOrderQuantityFailures: [MinOrderQuantityFailureDetails]!

  """
  If no identity token is provided with the request, then this mutation will create an anonymous cart. All
  anonymous carts have a token associated with them, which allows the client that created the cart to access
  that cart in the future. This is the only time this token is returned, so clients must store this securely
  in some type of local storage solution, and then send it along with all future anonymous cart queries and
  mutations.
  """
  token: String
}

"""
Describes the input for creating a discount code
"""
input CreateDiscountCodeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The discount code to update
  """
  discountCode: DiscountCodeInput

  """
  The shop ID of the discount code to update
  """
  shopId: ID!
}

"""
The response from the `createDiscountCode` mutation
"""
type CreateDiscountCodePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created discount code
  """
  discountCode: DiscountCode
}

"""
Input for the `createFlatRateFulfillmentMethod` mutation
"""
input CreateFlatRateFulfillmentMethodInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  This defines the flat rate fulfillment method that you want to create
  """
  method: FlatRateFulfillmentMethodInput!

  """
  The shop to create this flat rate fulfillment method for
  """
  shopId: ID!
}

"""
Response from the `createFlatRateFulfillmentMethod` mutation
"""
type CreateFlatRateFulfillmentMethodPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created fulfillment method
  """
  method: FlatRateFulfillmentMethod!
}

"""
Input for the `CreateFlatRateFulfillmentRestriction` mutation
"""
input CreateFlatRateFulfillmentRestrictionInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  This defines the flat rate fulfillment method restriction that you want to create
  """
  restriction: FlatRateFulfillmentRestrictionInput!

  """
  The shop to create this flat rate fulfillment method restriction for
  """
  shopId: ID!
}

"""
Response from the `CreateFlatRateFulfillmentRestriction` mutation
"""
type CreateFlatRateFulfillmentRestrictionPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created flat rate fulfillment method restriction
  """
  restriction: FlatRateFulfillmentRestriction!
}

"""
Input for the createMediaRecord mutation
"""
input CreateMediaRecordInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The media record to insert, with related file data already fully uploaded to temporary storage
  """
  mediaRecord: MediaRecordInput!

  """
  ID of shop that owns this MediaRecord
  """
  shopId: ID!
}

"""
Response payload for the createMediaRecord mutation
"""
type CreateMediaRecordPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created MediaRecord
  """
  mediaRecord: MediaRecord!
}

"""
Input for the `createNavigationItem` mutation
"""
input CreateNavigationItemInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The navigation item to create
  """
  navigationItem: NavigationItemInput!
}

"""
Response payload for the `createNavigationItem` mutation
"""
type CreateNavigationItemPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created navigation item
  """
  navigationItem: NavigationItem
}

"""
Input for the `createNavigationTree` mutation
"""
input CreateNavigationTreeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The draft navigation items that make up this tree
  """
  draftItems: [NavigationTreeItemInput]

  """
  The name of the tree, for operator display purposes
  """
  name: String!

  """
  The ID of the shop this navigation tree belongs to
  """
  shopId: ID!
}

"""
Response payload for the `createNavigationTree` mutation
"""
type CreateNavigationTreePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created navigation tree
  """
  navigationTree: NavigationTree!
}

"""
Input for the `createProduct` mutation
"""
input CreateProductInput {
  """
  Product input
  """
  product: ProductInput

  """
  ID of shop product will belong to
  """
  shopId: ID!

  """
  Set to false if you do not want to auto-create the first variant of the product
  """
  shouldCreateFirstVariant: Boolean = true
}

"""
Response payload of `createProduct` mutation
"""
type CreateProductPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created product
  """
  product: Product!
}

"""
Input for the `createProductVariant` mutation
"""
input CreateProductVariantInput {
  """
  ID of product variant belongs to
  """
  productId: ID!

  """
  ID of shop product variant will belong to
  """
  shopId: ID!

  """
  Variant input
  """
  variant: ProductVariantInput
}

"""
Response payload of `createProductVariant` mutation
"""
type CreateProductVariantPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created product variant
  """
  variant: ProductVariant!
}

"""
Input for the cancelOrderItem mutation
"""
input CreateRefundInput {
  """
  Amount to cancel. Must be equal to or less than the remaining non-refunded payment amount for this payment method.
  """
  amount: Float!

  """
  ID of the order that has the item you want to cancel
  """
  orderId: ID!

  """
  ID of the payment that you want to refund
  """
  paymentId: ID!

  """
  An optional free text reason for refund, which may be shown to operators
  or to the user who requested the refund.
  """
  reason: String
}

"""
Response payload for the createRefund mutation
"""
type CreateRefundPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Input parameters for the `createShop` mutation
"""
input CreateShopInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Currency in which all money values should be assumed to be. Default is `USD`.
  """
  currencyCode: String

  """
  Default language for translation and localization. Default is `en`.
  """
  defaultLanguage: String

  """
  Primary timezone. Default is `US/Pacific`
  """
  defaultTimezone: String

  """
  An optional description of the shop, intended for only admins to see
  """
  description: String

  """
  A unique name for the shop
  """
  name: String!

  """
  The shop type. Default is `primary`, but there may be only one primary shop.
  """
  type: String
}

"""
The response from the `createShop` mutation
"""
type CreateShopPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The shop which was created
  """
  shop: Shop!
}

"""
Input for the createStripePaymentIntent mutation
"""
input CreateStripePaymentIntentInput {
  """
  """
  cartId: String!

  """
  If this cart is anonymous, provide the `token` that was returned in the `CreateCartPayload`
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  """
  shopId: String!
}

"""
The response from the `createStripePaymentIntent` mutation
"""
type CreateStripePaymentIntentPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  """
  paymentIntentClientSecret: String
}

"""
Input for the `CreateSurcharge` mutation
"""
input CreateSurchargeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop to create this surcharge for
  """
  shopId: ID!

  """
  This defines the surcharge that you want to create
  """
  surcharge: SurchargeInput!
}

"""
Response from the `CreateSurcharge` mutation
"""
type CreateSurchargePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created surcharge
  """
  surcharge: Surcharge!
}

"""
The input for creating a tax rate
"""
input CreateTaxRateInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  An optional country code to limit where this tax is applied based on destination address
  """
  country: String

  """
  An optional postal code to limit where this tax is applied based on destination address
  """
  postal: String

  """
  The tax rate. For example, 0.05 for a 5% sales tax.
  """
  rate: Float!

  """
  An optional region (e.g., state) to limit where this tax is applied based on destination address
  """
  region: String

  """
  Shop ID
  """
  shopId: ID!

  """
  Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  """
  sourcing: TaxSource = destination

  """
  An optional tax code, to apply this tax rate to only products that have this tax code
  """
  taxCode: String
}

"""
The response from the `createTaxRate` mutation
"""
type CreateTaxRatePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The created tax rate
  """
  taxRate: TaxRate!
}

input CreateUserInput {
  email: String
  password: String
  username: String
}

type CreateUserResult {
  loginResult: LoginResult
  userId: ID
}

"""
Input for the createdAt database field
"""
input CreatedAtInput {
  """
  Start date, inclusive
  """
  gte: DateTime

  """
  End date, inclusive
  """
  lte: DateTime
}

"""
Represents one type of currency
"""
type Currency implements Node {
  """
  ID
  """
  _id: ID!

  """
  Currency code
  """
  code: String!

  """
  Decimal symbol
  """
  decimal: String

  """
  Format string
  """
  format: String!

  """
  Exchange rate from shop default currency, if known
  """
  rate: Float

  """
  The decimal scale used by this currency
  """
  scale: Int

  """
  Currency symbol
  """
  symbol: String!

  """
  Thousands separator symbol
  """
  thousand: String
}

"""
The product price or price range for a specific currency
"""
type CurrencyExchangeProductPricingInfo {
  """
  A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  only purchasable variants will have a `compareAtPrice`.
  """
  compareAtPrice: Money

  """
  The code for the currency these pricing details applies to
  """
  currency: Currency!

  """
  UI should display this price. If a product has multiple potential prices depending on selected
  variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  symbols.
  """
  displayPrice: String!

  """
  The price of the most expensive possible variant+option combination
  """
  maxPrice: Float!

  """
  The price of the least expensive possible variant+option combination
  """
  minPrice: Float!

  """
  For variants with no options and for options, this will always be set to a price. For variants
  with options and products, this will be `null`. There must be a price for a variant to be
  added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  """
  price: Float
}

"""
Represents Mongo Database information
"""
type DatabaseInformation {
  """
  Version of database
  """
  version: String!
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""
Objects implementing the Deletable support soft deletion
"""
interface Deletable {
  """
  If true, this object should be considered deleted. Soft deleted objects are not
  returned in query results unless you explicitly ask for them.
  """
  isDeleted: Boolean!
}

"""
Input for the `deleteAddressValidationRule` mutation
"""
input DeleteAddressValidationRuleInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of the rule you want to delete
  """
  ruleId: ID!

  """
  Shop ID of the rule you want to delete
  """
  shopId: ID!
}

"""
Payload for the `deleteAddressValidationRule` mutation
"""
type DeleteAddressValidationRulePayload {
  """
  Deleted address validation rule
  """
  addressValidationRule: AddressValidationRule!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Describes the input for removing a discount code
"""
input DeleteDiscountCodeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The discount code ID
  """
  discountCodeId: ID!

  """
  Shop ID
  """
  shopId: ID!
}

"""
The response from the `deleteDiscountCode` mutation
"""
type DeleteDiscountCodePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The deleted discount code
  """
  discountCode: DiscountCode
}

"""
Input for the `deleteFlatRateFulfillmentMethod` mutation
"""
input DeleteFlatRateFulfillmentMethodInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the flat rate fulfillment method you want to delete
  """
  methodId: ID!

  """
  The shop that owns the method
  """
  shopId: ID!
}

"""
Response from the `deleteFlatRateFulfillmentMethod` mutation
"""
type DeleteFlatRateFulfillmentMethodPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The removed fulfillment method
  """
  method: FlatRateFulfillmentMethod!
}

"""
Input for the `deleteFlatRateFulfillmentRestriction` mutation
"""
input DeleteFlatRateFulfillmentRestrictionInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the flat rate fulfillment method restriction you want to delete
  """
  restrictionId: ID!

  """
  The shop that owns the flat rate fulfillment method restriction
  """
  shopId: ID!
}

"""
Response from the `deleteFlatRateFulfillmentRestriction` mutation
"""
type DeleteFlatRateFulfillmentRestrictionPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The removed flat rate fulfillment method restriction
  """
  restriction: FlatRateFulfillmentRestriction!
}

"""
Input for the deleteMediaRecord mutation
"""
input DeleteMediaRecordInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of MediaRecord to delete
  """
  mediaRecordId: ID!

  """
  ID of shop that owns this MediaRecord
  """
  shopId: ID!
}

"""
Response payload for the deleteMediaRecord mutation
"""
type DeleteMediaRecordPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The deleted MediaRecord
  """
  mediaRecord: MediaRecord!
}

"""
Input for the `deleteNavigationItem` mutation
"""
input DeleteNavigationItemInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the navigation item to delete
  """
  id: ID!

  """
  The ID of the shop navigation item belongs to
  """
  shopId: ID!
}

"""
Response payload for the `deleteNavigationItem` mutation
"""
type DeleteNavigationItemPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The deleted navigation item
  """
  navigationItem: NavigationItem
}

"""
Input for the `deleteSurcharge` mutation
"""
input DeleteSurchargeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop that owns the method
  """
  shopId: ID!

  """
  The ID of the flat rate fulfillment method you want to delete
  """
  surchargeId: ID!
}

"""
Response from the `deleteSurcharge` mutation
"""
type DeleteSurchargePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The removed fulfillment method
  """
  surcharge: Surcharge!
}

"""
Describes the input for removing a tax rate
"""
input DeleteTaxRateInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Shop ID
  """
  shopId: ID!

  """
  The tax rate ID
  """
  taxRateId: ID!
}

"""
The response from the `deleteTaxRate` mutation
"""
type DeleteTaxRatePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The deleted tax rate
  """
  taxRate: TaxRate!
}

"""
Destination restriction conditions. If multiple of `country`,
`region`, and `postal` are set, there is an AND relationship.
"""
type DestinationRestrictions {
  """
  Restrict for any of these destination countries
  """
  country: [String]

  """
  Restrict for any of these destination postal codes
  """
  postal: [String]

  """
  Restrict for any of these destination regions
  """
  region: [String]
}

"""
Input for a destination restriction condition
"""
input DestinationRestrictionsInput {
  """
  Restrict for any of these destination countries
  """
  country: [String]

  """
  Restrict for any of these destination postal codes
  """
  postal: [String]

  """
  Restrict for any of these destination regions
  """
  region: [String]
}

"""
Discount code calculation
"""
type DiscountCalculation {
  """
  Discount code calculation method
  """
  method: DiscountCalculationMethod
}

"""
Input type for discount calculation
"""
input DiscountCalculationInput {
  """
  Discount code calculation method
  """
  method: DiscountCalculationMethod
}

"""
Discount calculation types
"""
enum DiscountCalculationMethod {
  """
  Store credit
  """
  credit

  """
  Discount of order
  """
  discount

  """
  Sale on an item
  """
  sale

  """
  Discount to shipping
  """
  shipping
}

"""
A discount code
"""
type DiscountCode {
  """
  Discount code ID
  """
  _id: ID!

  """
  How the discount should be applied
  """
  calculation: DiscountCalculation

  """
  Discount Code
  """
  code: String!

  """
  Discount code conditions
  """
  conditions: DiscountConditions

  """
  Description to describe the discount code
  """
  description: String

  """
  Discount is allowed to be string or number.
  it's a formula value (could be shipping code)
  """
  discount: String

  """
  Discount method type
  """
  discountMethod: DiscountMethod

  """
  Label to describe the code
  """
  label: String

  """
  The shop to which this DiscountCode belongs to
  """
  shop: Shop!

  """
  History of transactions
  """
  transactions: [DiscountTransaction]
}

"""
Wraps a list of DiscountCode`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type DiscountCodeConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [DiscountCodeEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [DiscountCode]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `DiscountCode` object
"""
type DiscountCodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The discount code
  """
  node: DiscountCode
}

"""
Input type for filters to be applied to an discount codes list
"""
input DiscountCodeFilterInput {
  """
  Keywords typed by the user in the search input field
  """
  searchField: String
}

"""
Input type for a discount code
"""
input DiscountCodeInput {
  """
  How the discount should be applied
  """
  calculation: DiscountCalculationInput

  """
  Discount Code
  """
  code: String!

  """
  Discount code conditions
  """
  conditions: DiscountConditionsInput

  """
  Description to describe the discount code
  """
  description: String

  """
  Discount is allowed to be string or number.
  it's a formula value (could be shipping code)
  """
  discount: String

  """
  Discount method type
  """
  discountMethod: DiscountMethod

  """
  Label to describe the code
  """
  label: String

  """
  History of transactions
  """
  transactions: [DiscountTransactionInput]
}

"""
The conditions an order must meet for a discount code to be applied
"""
type DiscountConditionOrder {
  """
  Order date range end
  """
  endDate: DateTime

  """
  Maximum order value
  """
  max: Float

  """
  Minimum order value
  """
  min: Float!

  """
  Order date range start
  """
  startDate: DateTime
}

"""
Discount order conditions input type
"""
input DiscountConditionOrderInput {
  """
  Order date range end
  """
  endDate: DateTime

  """
  Maximum order value
  """
  max: Float

  """
  Minimum order value
  """
  min: Float!

  """
  Order date range start
  """
  startDate: DateTime
}

"""
Conditions for a discount code to be applied
"""
type DiscountConditions {
  """
  Account Limit
  """
  accountLimit: Int

  """
  Audience that may apply this discount code
  """
  audience: [String]

  """
  Is this discount code enabled
  """
  enabled: Boolean!

  """
  Order conditions
  """
  order: DiscountConditionOrder

  """
  Permissions that may apply this discount code
  """
  permissions: [String]

  """
  Products that may apply this discount code
  """
  products: [String]

  """
  Number of times this code may be redeemed.
  Setting to 100 means the first 100 customers may apply this code.
  Setting this value to 0 will allow this code to be applied an infinite number of times.
  """
  redemptionLimit: Int

  """
  Tags that may be apply this discount code
  """
  tags: [String]
}

"""
Discount conditions input type
"""
input DiscountConditionsInput {
  """
  Account Limit
  """
  accountLimit: Int

  """
  Audience that may apply this discount code
  """
  audience: [String]

  """
  Is this discount code enabled
  """
  enabled: Boolean!

  """
  Order conditions
  """
  order: DiscountConditionOrderInput

  """
  Permissions that may apply this discount code
  """
  permissions: [String]

  """
  Products that may apply this discount code
  """
  products: [String]

  """
  Number of times this code may be redeemed.
  Setting to 100 means the first 100 customers may apply this code.
  Setting this value to 0 will allow this code to be applied an infinite number of times.
  """
  redemptionLimit: Int

  """
  Tags that may be apply this discount code
  """
  tags: [String]
}

"""
Discount method types
"""
enum DiscountMethod {
  """
  Code type
  """
  code

  """
  Rate type
  """
  rate
}

"""
Transaction history for a discount code
"""
type DiscountTransaction {
  """
  Date the code was applied
  """
  appliedAt: DateTime

  """
  Cart id
  """
  cartId: String!

  """
  User id
  """
  userId: String!
}

"""
Discount transation input type
"""
input DiscountTransactionInput {
  """
  Date the code was applied
  """
  appliedAt: DateTime

  """
  Cart id
  """
  cartId: String!

  """
  User id
  """
  userId: String!
}

"""
Distance units
"""
enum DistanceUnit {
  """
  Centimeter
  """
  cm

  """
  Foot
  """
  ft

  """
  Inch
  """
  in
}

"""
A string email address
"""
scalar Email

"""
An e-mail job
"""
type EmailJob {
  """
  The ID of the e-mail job
  """
  _id: ID!

  """
  The date and time of the creation of the e-mail job
  """
  createdAt: DateTime!

  """
  The data of the e-mail
  """
  data: EmailJobData!

  """
  The status of the e-mail job
  """
  status: String!

  """
  To be deprecated. Use updatedAt instead. The date and time of the last update to the e-mail job.
  """
  updated: DateTime!

  """
  The date and time of the last update to the e-mail job
  """
  updatedAt: DateTime!
}

"""
Wraps a list of `EmailJob`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type EmailJobConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [EmailJobEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [EmailJob]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
The data of the e-mail
"""
type EmailJobData {
  """
  The subject of the e-mail
  """
  subject: String!

  """
  The address the e-mail was/is being/will be sent to
  """
  to: String!
}

"""
A connection edge in which each node is an `EmailJob` object
"""
type EmailJobEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The product
  """
  node: EmailJob
}

"""
A confirmable email record
"""
type EmailRecord {
  """
  The actual email address
  """
  address: String

  """
  The services provided by this address
  """
  provides: String

  """
  Has this address been verified?
  """
  verified: Boolean
}

"""
A confirmable email record
"""
input EmailRecordInput {
  """
  The actual email address
  """
  address: String

  """
  The services provided by this address
  """
  provides: String

  """
  Has this address been verified?
  """
  verified: Boolean
}

"""
Input for the `enablePaymentMethodForShop` mutation
"""
input EnablePaymentMethodForShopInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  True to enable it or false to disable it
  """
  isEnabled: Boolean!

  """
  The name of the payment method to enable or disable
  """
  paymentMethodName: String!

  """
  The ID of the shop for which this payment method should be enabled or disabled
  """
  shopId: ID!
}

"""
Response payload for the `enablePaymentMethodForShop` mutation
"""
type EnablePaymentMethodForShopPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The full list of payment methods for the shop
  """
  paymentMethods: [PaymentMethod]!
}

"""
Data for an example IOU payment
"""
type ExampleIOUPaymentData {
  """
  The name of the IOU payer entered by the shopper
  """
  fullName: String!
}

"""
Data for an example IOU payment method
"""
type ExampleIOUPaymentMethodData {
  """
  Example
  """
  example: String!
}

"""
Do not use this
"""
type FakeData {
  """
  Do not use this
  """
  doNotUse: String
}

"""
Defines a fulfillment method that has a fixed price. This type is provided by the `flat-rate` fulfillment plugin.
"""
type FlatRateFulfillmentMethod implements Node {
  """
  The flat rate fulfillment method ID
  """
  _id: ID!

  """
  The cost of this fulfillment method to the shop, if you track this
  """
  cost: Float

  """
  The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  """
  fulfillmentTypes: [FulfillmentType]!

  """
  The group to which this method belongs
  """
  group: String!

  """
  A fixed price to charge for handling costs when this fulfillment method is selected for an order
  """
  handling: Float!

  """
  Include this as a fulfillment option shown to shoppers during checkout?
  """
  isEnabled: Boolean!

  """
  The name of this method, for display in the user interface
  """
  label: String!

  """
  The name of this method, a unique identifier
  """
  name: String!

  """
  A fixed price to charge for fulfillment costs when this fulfillment method is selected for an order
  """
  rate: Float!

  """
  The shop to which this fulfillment method belongs
  """
  shop: Shop!
}

"""
Wraps a list of FlatRateFulfillmentMethods`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type FlatRateFulfillmentMethodConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [FlatRateFulfillmentMethodEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [FlatRateFulfillmentMethod]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `FlatRateFulfillmentMethod` object
"""
type FlatRateFulfillmentMethodEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The fulfillment method
  """
  node: FlatRateFulfillmentMethod
}

"""
Defines a fulfillment method that has a fixed price. This type is provided by the `flat-rate` fulfillment plugin.
"""
input FlatRateFulfillmentMethodInput {
  """
  The cost of this fulfillment method to the shop, if you track this
  """
  cost: Float

  """
  The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  """
  fulfillmentTypes: [FulfillmentType]!

  """
  The group to which this method belongs
  """
  group: String!

  """
  A fixed price to charge for handling costs when this fulfillment method is selected for an order
  """
  handling: Float!

  """
  Include this as a fulfillment option shown to shoppers during checkout?
  """
  isEnabled: Boolean!

  """
  The name of this method, for display in the user interface
  """
  label: String!

  """
  The name of this method, a unique identifier
  """
  name: String!

  """
  A fixed price to charge for fulfillment costs when this fulfillment method is selected for an order
  """
  rate: Float!
}

"""
Defines a flat rate fulfillment method restriction.
"""
type FlatRateFulfillmentRestriction implements Node {
  """
  The restriction ID.
  """
  _id: ID!

  """
  Attribute restrictions. Multiple attribute restrictions are evaluated with AND. If both destination and attribute restrictions are present, they evaluate with AND.
  """
  attributes: [AttributeRestrictions]

  """
  Destination restrictions. If multiple destination restrictions are present, the most localized is the only one evaluated (i.e. evaluate postal if present, then region if present, then country). If both destination and attribute restrictions are present, they evaluate with AND.
  """
  destination: DestinationRestrictions

  """
  Method IDs to apply this restriction to. If none, applies to all methods as a universal restriction.
  """
  methodIds: [ID]

  """
  The shop ID
  """
  shopId: ID!

  """
  The type of this restriction. Allowed types are `allow` or `deny`.
  """
  type: RestrictionTypeEnum!
}

"""
Wraps a list of `FlatRateFulfillmentRestriction`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type FlatRateFulfillmentRestrictionConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [FlatRateFulfillmentRestrictionEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [FlatRateFulfillmentRestriction]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `FlatRateFulfillmentRestriction` object
"""
type FlatRateFulfillmentRestrictionEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The flat rate fulfillment restriction
  """
  node: FlatRateFulfillmentRestriction
}

"""
Defines the input for a flat rate fulfillment method restriction.
"""
input FlatRateFulfillmentRestrictionInput {
  """
  Attribute restrictions. Multiple attribute restrictions are evaluated with AND. If both destination and attribute restrictions are present, they evaluate with AND.
  """
  attributes: [AttributeRestrictionsInput]

  """
  Destination restrictions. If multiple destination restrictions are present, the most localized is the only one evaluated (i.e. evaluate postal if present, then region if present, then country). If both destination and attribute restrictions are present, they evaluate with AND.
  """
  destination: DestinationRestrictionsInput

  """
  Method IDs to apply this restriction to. If none, applies to all methods as a universal restriction.
  """
  methodIds: [ID]

  """
  The type of this restriction. Allowed types are `allow` or `deny`.
  """
  type: RestrictionTypeEnum!
}

"""
Allowed values for `FlatRateFulfillmentRestriction` sortBy parameter
"""
enum FlatRateFulfillmentRestrictionSortByField {
  """
  Date the restriction was created
  """
  createdAt
}

"""
Information needed by the selected fulfillment method to properly fulfill the order
"""
type FulfillmentData {
  """
  The mailing address to which this fulfillment group should be shipped
  """
  shippingAddress: Address
}

"""
Links one or more cart items to fulfillment data. The most common example is having one FulfillmentGroup
per shipping address.
"""
type FulfillmentGroup implements Node {
  """
  The fulfillment ID
  """
  _id: ID!

  """
  The list of fulfillment options from which the shopper may choose. This list is created by taking
  the full list of registered fulfillment methods, keeping only those that match the fulfillment `type`
  of this group, and then calculating a price and handlingPrice for each based on the `items` in this group.
  """
  availableFulfillmentOptions: [FulfillmentOption]!

  """
  Information needed by the fulfillment type to properly fulfill the order
  """
  data: FulfillmentData

  """
  The items that are included in this fulfillment group
  """
  items: [CartItem]!

  """
  The fulfillment method selected by a shopper for this group, with its associated price
  """
  selectedFulfillmentOption: FulfillmentOption

  """
  The shipping address collected for this group, if relevant
  """
  shippingAddress: Address

  """
  The shop that owns the items in this group and is responsible for fulfillment
  """
  shop: Shop!

  """
  The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  """
  type: FulfillmentType!
}

"""
A single fulfillment method. Fulfillment methods are shown to shoppers along with a quote for them,
and the shopper chooses one method per fulfillment group per cart during checkout.
"""
type FulfillmentMethod implements Node {
  """
  The fulfillment method ID
  """
  _id: ID!

  """
  A carrier name
  """
  carrier: String

  """
  The name of this method, for display in the user interface
  """
  displayName: String!

  """
  The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  """
  fulfillmentTypes: [FulfillmentType]!

  """
  The group to which this method belongs
  """
  group: String

  """
  The name of this method, a unique identifier
  """
  name: String!
}

"""
A fulfillment option for a cart fulfillment group, which is a method with an associated price
"""
type FulfillmentOption {
  """
  The fulfillment method this pricing is for
  """
  fulfillmentMethod: FulfillmentMethod

  """
  The additional amount charged for handling
  """
  handlingPrice: Money!

  """
  The base price charged
  """
  price: Money!
}

"""
Allowed fulfillment types
"""
enum FulfillmentType {
  """
  An order will be fulfilled digitally, such as by sending a download link
  """
  digital

  """
  An order will be fulfilled by the customer picking it up
  """
  pickup

  """
  An order will be fulfilled by the seller shipping it to the customer
  """
  shipping
}

"""
Input for the `generateSitemaps` mutation
"""
input GenerateSitemapsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the shop to generate sitemap for
  """
  shopId: ID!
}

"""
Response for the `generateSitemaps` mutation
"""
type GenerateSitemapsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Whether the sitemap generation job was successfully scheduled
  """
  wasJobScheduled: Boolean!
}

"""
App settings that are not shop specific. Plugins extend the GlobalSettings type to support
whatever settings they need.
"""
type GlobalSettings {
  """
  A fake setting necessary until some plugin extends this with a real setting
  """
  doNotUse: String
}

"""
Updates for app settings that are not shop specific. Plugins extend
this input type to support whatever settings they need. All fields
must be optional.
"""
input GlobalSettingsUpdates {
  """
  Do not use this field
  """
  doNotUse: String
}

"""
"""
input GrantOrRevokeAdminUIAccessInput {
  """
  The account ID to update
  """
  accountId: String!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop IDs to unassign or assign to the accounts
  """
  shopId: String!
}

"""
"""
type GrantOrRevokeAdminUIAccessPayload {
  """
  The up to date account object
  """
  account: Account

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
Represents an account group
"""
type Group implements Node {
  """
  The group ID
  """
  _id: ID!

  """
  The date and time at which this group was created
  """
  createdAt: DateTime!

  """
  The account that created this group
  """
  createdBy: Account

  """
  A free text description of this group
  """
  description: String

  """
  A unique name for the group
  """
  name: String!

  """
  A list of the account permissions implied by membership in this group
  """
  permissions: [String]

  """
  The shop to which this group belongs
  """
  shop: Shop

  """
  A unique URL-safe string representing this group
  """
  slug: String!

  """
  The date and time at which this group was last updated
  """
  updatedAt: DateTime!
}

"""
Wraps a list of `Groups`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type GroupConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [GroupEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Group]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `Group` object
"""
type GroupEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The group
  """
  node: Group
}

"""
A group definition
"""
input GroupInput {
  """
  A free text description of this group
  """
  description: String

  """
  A unique name for the group
  """
  name: String!

  """
  A list of the account permissions implied by membership in this group
  """
  permissions: [String]

  """
  A unique URL-safe string representing this group
  """
  slug: String
}

"""
The fields by which you are allowed to sort any query that returns an `GroupConnection`
"""
enum GroupSortByField {
  """
  Group ID
  """
  _id

  """
  Date and time at which this group was created
  """
  createdAt

  """
  Group name
  """
  name

  """
  Date and time at which this group was last updated
  """
  updatedAt
}

"""
Information about an image
"""
type ImageInfo {
  """
  A list of URLs for various size files of this image
  """
  URLs: ImageSizes

  """
  ID
  """
  _id: ID

  """
  Sort by priority ascending when displaying more than one image for a product in a user interface.
  This is an integer with 1 being the first / highest priority image.
  """
  priority: Int

  """
  The related product ID
  """
  productId: ID

  """
  The related variant ID, if linked with a particular variant
  """
  variantId: ID
}

"""
A list of URLs for various sizes of an image
"""
type ImageSizes {
  """
  Use this URL to get a large resolution file for this image
  """
  large: String

  """
  Use this URL to get a medium resolution file for this image
  """
  medium: String

  """
  Use this URL to get this image with its original resolution as uploaded. This may not be
  the true original size if there is a hard cap on how big image files can be.
  """
  original: String

  """
  Use this URL to get a small resolution file for this image
  """
  small: String

  """
  Use this URL to get a thumbnail resolution file for this image
  """
  thumbnail: String
}

type ImpersonateReturn {
  authorized: Boolean
  tokens: Tokens
  user: User
}

input ImpersonationUserIdentityInput {
  email: String
  userId: String
  username: String
}

"""
Details about a CartItemInput that failed to be added to a cart due to a price mismatch
"""
type IncorrectPriceFailureDetails {
  """
  The current price in the system for this product configuration in the requested currency
  """
  currentPrice: Money!

  """
  The productConfiguration that was provided with the CartItemInput that caused this failure
  """
  productConfiguration: ProductConfiguration!

  """
  The price that was provided with the CartItemInput that caused this failure
  """
  providedPrice: Money!
}

"""
Represents a single staff member invitation
"""
type Invitation implements Node {
  """
  The invitation ID
  """
  _id: ID!

  """
  The e-mail address the invitation was sent to
  """
  email: String!

  """
  The groups this person was invited to
  """
  groups: [Group]!

  """
  The admin who invited this person
  """
  invitedBy: Account

  """
  The shop this person was invited to. Optional because we can also invite merchants to create their own shops.
  """
  shop: Shop
}

"""
Wraps a list of `Invitation`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type InvitationConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [InvitationEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Invitation]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is an `Invitation` object
"""
type InvitationEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The account
  """
  node: Invitation
}

"""
Input parameters for the inviteShopMember mutation
"""
input InviteShopMemberInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address of the person to invite
  """
  email: String!

  """
  The permission group for this person's new account. DEPRECATED. Use `groupIds` field instead.
  """
  groupId: ID

  """
  The permission groups for this person's new account
  """
  groupIds: [ID]

  """
  The invitee's full name
  """
  name: String!

  """
  The ID of the shop to which you want to invite this person
  """
  shopId: ID!

  """
  Whether the newly invited user should get admin UI access to the shop upon sign-up
  """
  shouldGetAdminUIAccess: Boolean
}

"""
The response from the `inviteShopMember` mutation
"""
type InviteShopMemberPayload {
  """
  The account that was successfully created or found and updated by inviting this shop member
  """
  account: Account

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
An object with any fields
"""
scalar JSONObject

type LoginResult {
  sessionId: String
  tokens: Tokens
  user: User
}

"""
Mass units
"""
enum MassUnit {
  """
  Gram
  """
  g

  """
  Kilogram
  """
  kg

  """
  Pound
  """
  lb

  """
  Ounce
  """
  oz
}

"""
A FileRecord for a media file
"""
type MediaRecord {
  """
  MediaRecord ID
  """
  _id: ID!

  """
  Custom metadata for the media record
  """
  metadata: MediaRecordMetadata!

  """
  Core info about the original uploaded file
  """
  original: MediaRecordInfo!
}

"""
Core info about the original uploaded media file
"""
type MediaRecordInfo {
  """
  File name
  """
  name: String!

  """
  File size
  """
  size: Int!

  """
  File type
  """
  type: String!

  """
  Date and time at which the file was last updated
  """
  updatedAt: DateTime!

  """
  Date and time at which the file was uploaded
  """
  uploadedAt: DateTime!
}

"""
Core info about the original uploaded media file
"""
input MediaRecordInfoInput {
  """
  File name
  """
  name: String!

  """
  File size
  """
  size: Int!

  """
  ID of the file uploaded to temporary storage
  """
  tempStoreId: String!

  """
  File type
  """
  type: String!

  """
  Date and time at which the file was last updated
  """
  updatedAt: DateTime!

  """
  Date and time at which the file was uploaded
  """
  uploadedAt: DateTime!
}

"""
A FileRecord for a media file
"""
input MediaRecordInput {
  """
  Custom metadata for the media record
  """
  metadata: MediaRecordMetadataInput!

  """
  Core info about the original uploaded file
  """
  original: MediaRecordInfoInput!
}

"""
Custom metadata for the media record
"""
type MediaRecordMetadata {
  """
  True if the MediaRecord is archived. This typically means that the media will not show in a storefront but the image file data still exists.
  """
  isArchived: Boolean!

  """
  ID of the account that uploaded the file
  """
  ownerId: String

  """
  Priority among media files with similar metadata
  """
  priority: Int

  """
  ID of the related product, if the media is for a product
  """
  productId: String

  """
  ID of the shop that owns the media
  """
  shopId: String!

  """
  A string that identifies where this media will be used, for filtering
  """
  type: String

  """
  ID of the related product variant, if the media is for a product variant
  """
  variantId: String
}

"""
Custom metadata for the media record
"""
input MediaRecordMetadataInput {
  """
  Priority among media files with similar metadata
  """
  priority: Int

  """
  ID of the related product, if the media is for a product
  """
  productId: ID

  """
  A string that identifies where this media will be used, for filtering
  """
  type: String

  """
  ID of the related product variant, if the media is for a product variant
  """
  variantId: ID
}

"""
Input to add a surcharge message with language
"""
input MessagesByLanguageInput {
  """
  The message for this language
  """
  content: String!

  """
  The language code
  """
  language: String!
}

"""
User defined attributes
"""
type Metafield {
  """
  Field description
  """
  description: String

  """
  Field key
  """
  key: String

  """
  Field namespace
  """
  namespace: String

  """
  Field scope
  """
  scope: String

  """
  Field value
  """
  value: String

  """
  Field value type
  """
  valueType: String
}

"""
User defined attributes. You can include only `key` and use these like tags, or also include a `value`.
"""
input MetafieldInput {
  """
  Field description
  """
  description: String

  """
  Field key
  """
  key: String!

  """
  Field namespace
  """
  namespace: String

  """
  Field scope
  """
  scope: String

  """
  Field value
  """
  value: String

  """
  Field value type
  """
  valueType: String
}

"""
Details about a CartItemInput that failed to be added to a cart due to a quantity error
"""
type MinOrderQuantityFailureDetails {
  """
  The minimum quantity that can be added to a cart
  """
  minOrderQuantity: Int!

  """
  The productConfiguration that was provided with the CartItemInput that caused this failure
  """
  productConfiguration: ProductConfiguration!

  """
  The quantity that was provided with the CartItemInput that caused this failure
  """
  quantity: Int!
}

"""
Represents some amount of a single currency
"""
type Money {
  """
  The numeric amount
  """
  amount: Float!

  """
  The currency, for interpreting the `amount`
  """
  currency: Currency!

  """
  The display amount, with any currency symbols and decimal places already added
  """
  displayAmount: String!
}

"""
Represents input for some amount of a single currency
"""
input MoneyInput {
  """
  The numeric amount
  """
  amount: Float!

  """
  The currency code, for interpreting the `amount`
  """
  currencyCode: String!
}

"""
Input for the moveOrderItems mutation
"""
input MoveOrderItemsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the order fulfillment group from which all the items are to be moved.
  """
  fromFulfillmentGroupId: ID!

  """
  The list of item IDs to move. The full quantity must be moved.
  """
  itemIds: [ID]!

  """
  ID of the order that has the items you want to move
  """
  orderId: ID!

  """
  The ID of the order fulfillment group to which all the items are to be moved.
  """
  toFulfillmentGroupId: ID!
}

"""
Response payload for the moveOrderItems mutation
"""
type MoveOrderItemsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Mutations have side effects, such as mutating data or triggering a task
"""
type Mutation {
  """
  Add a new address to the `addressBook` field for an account
  """
  addAccountAddressBookEntry(
    """
    Mutation input
    """
    input: AddAccountAddressBookEntryInput!
  ): AddAccountAddressBookEntryPayload

  """
  Add an email address to an account
  """
  addAccountEmailRecord(
    """
    Mutation input
    """
    input: AddAccountEmailRecordInput!
  ): AddAccountEmailRecordPayload

  """
  Add an account to a group
  """
  addAccountToGroup(
    """
    Mutation input
    """
    input: AddAccountToGroupInput!
  ): AddAccountToGroupPayload

  """
  Add item(s) to a cart
  """
  addCartItems(
    """
    Mutation input
    """
    input: AddCartItemsInput!
  ): AddCartItemsPayload!
  addEmail(newEmail: String!): Boolean

  """
  Use this mutation to add a new order fulfillment group to an order. It must have at least one
  item. Items may be provided or moved from another existing group or both.
  """
  addOrderFulfillmentGroup(
    """
    Mutation input
    """
    input: AddOrderFulfillmentGroupInput!
  ): AddOrderFulfillmentGroupPayload!

  """
  Adds a new tag
  """
  addTag(
    """
    Mutation input
    """
    input: AddTagInput!
  ): AddTagPayload!

  """
  Bulk operation for adding an array of tags to an array of products
  """
  addTagsToProducts(
    """
    input which must includes an array of product ids and an array of tag ids
    """
    input: ProductTagsOperationInput!
  ): ProductTagsOperationPayload!

  """
  Apply a discount code to a cart
  """
  applyDiscountCodeToCart(
    """
    Mutation input
    """
    input: ApplyDiscountCodeToCartInput!
  ): ApplyDiscountCodeToCartPayload!

  """
  Approve one or more payments for an order
  """
  approveOrderPayments(
    """
    Mutation input
    """
    input: ApproveOrderPaymentsInput!
  ): ApproveOrderPaymentsPayload!

  """
  Archive a MediaRecord to hide it without deleting the backing file data
  """
  archiveMediaRecord(
    """
    Mutation input
    """
    input: ArchiveMediaRecordInput!
  ): ArchiveMediaRecordPayload!

  """
  Archive product variants
  """
  archiveProductVariants(
    """
    Mutation input
    """
    input: ArchiveProductVariantsInput!
  ): ArchiveProductVariantsPayload!

  """
  Archive products
  """
  archiveProducts(
    """
    Mutation input
    """
    input: ArchiveProductsInput!
  ): ArchiveProductsPayload!
  authenticate(
    params: AuthenticateParamsInput!
    serviceName: String!
  ): LoginResult

  """
  Use this mutation to cancel one item of an order, either for the full ordered quantity
  or for a partial quantity. If partial, the item will be split into two items and the
  original item will have a lower quantity and will be canceled.

  If this results in all items in a fulfillment group being canceled, the group will also
  be canceled. If this results in all fulfillment groups being canceled, the full order will
  also be canceled.
  """
  cancelOrderItem(
    """
    Mutation input
    """
    input: CancelOrderItemInput!
  ): CancelOrderItemPayload!

  """
  Capture one or more payments for an order
  """
  captureOrderPayments(
    """
    Mutation input
    """
    input: CaptureOrderPaymentsInput!
  ): CaptureOrderPaymentsPayload!
  changePassword(newPassword: String!, oldPassword: String!): Boolean

  """
  Clone an existing product variant
  """
  cloneProductVariants(
    """
    Mutation input
    """
    input: CloneProductVariantsInput!
  ): CloneProductVariantsPayload!

  """
  Clone an existing product
  """
  cloneProducts(
    """
    Mutation input
    """
    input: CloneProductsInput!
  ): CloneProductsPayload!

  """
  Create an account based off a user
  """
  createAccount(
    """
    Mutation input
    """
    input: CreateAccountInput!
  ): CreateAccountPayload

  """
  Create a new account group. These are usually used for account permissions
  """
  createAccountGroup(
    """
    Mutation input
    """
    input: CreateAccountGroupInput!
  ): CreateAccountGroupPayload

  """
  Create an address validation rule
  """
  createAddressValidationRule(
    """
    Mutation input
    """
    input: CreateAddressValidationRuleInput!
  ): CreateAddressValidationRulePayload!

  """
  Create a new cart
  """
  createCart(
    """
    Mutation input
    """
    input: CreateCartInput!
  ): CreateCartPayload!

  """
  Create a new discount code
  """
  createDiscountCode(
    """
    Mutation input
    """
    input: CreateDiscountCodeInput!
  ): CreateDiscountCodePayload

  """
  Create a flat rate fulfillment method
  """
  createFlatRateFulfillmentMethod(
    """
    Mutation input
    """
    input: CreateFlatRateFulfillmentMethodInput!
  ): CreateFlatRateFulfillmentMethodPayload!

  """
  Create a flat rate fulfillment method restriction.
  """
  createFlatRateFulfillmentRestriction(
    """
    Mutation input
    """
    input: CreateFlatRateFulfillmentRestrictionInput!
  ): CreateFlatRateFulfillmentRestrictionPayload!

  """
  Create the MediaRecord for file data after you upload it
  """
  createMediaRecord(
    """
    Mutation input
    """
    input: CreateMediaRecordInput!
  ): CreateMediaRecordPayload!

  """
  Create a new navigation item
  """
  createNavigationItem(
    """
    Mutation input
    """
    input: CreateNavigationItemInput!
  ): CreateNavigationItemPayload

  """
  Create a new navigation tree
  """
  createNavigationTree(
    """
    Mutation input
    """
    input: CreateNavigationTreeInput!
  ): CreateNavigationTreePayload!

  """
  Create a new product
  """
  createProduct(
    """
    Mutation input
    """
    input: CreateProductInput!
  ): CreateProductPayload!

  """
  Create a new product variant
  """
  createProductVariant(
    """
    Mutation input
    """
    input: CreateProductVariantInput!
  ): CreateProductVariantPayload!

  """
  Use this mutation to create a refund on a payment method used to make the order
  """
  createRefund(
    """
    Mutation input
    """
    input: CreateRefundInput!
  ): CreateRefundPayload!

  """
  Create a new shop
  """
  createShop(
    """
    Mutation input
    """
    input: CreateShopInput!
  ): CreateShopPayload!

  """
  Create Stripe payment intent for the current cart and return a token
  """
  createStripePaymentIntent(
    input: CreateStripePaymentIntentInput!
  ): CreateStripePaymentIntentPayload!

  """
  Create a surcharge
  """
  createSurcharge(
    """
    Mutation input
    """
    input: CreateSurchargeInput!
  ): CreateSurchargePayload!

  """
  Create a new tax rate
  """
  createTaxRate(
    """
    Mutation input
    """
    input: CreateTaxRateInput!
  ): CreateTaxRatePayload
  createUser(user: CreateUserInput!): CreateUserResult

  """
  Delete an address validation rule
  """
  deleteAddressValidationRule(
    """
    Mutation input
    """
    input: DeleteAddressValidationRuleInput!
  ): DeleteAddressValidationRulePayload!

  """
  Delete a discount code
  """
  deleteDiscountCode(
    """
    Mutation input
    """
    input: DeleteDiscountCodeInput!
  ): DeleteDiscountCodePayload

  """
  Delete a flat rate fulfillment method
  """
  deleteFlatRateFulfillmentMethod(
    """
    Mutation input
    """
    input: DeleteFlatRateFulfillmentMethodInput!
  ): DeleteFlatRateFulfillmentMethodPayload!

  """
  Delete a flat rate fulfillment method restriction
  """
  deleteFlatRateFulfillmentRestriction(
    """
    Mutation input
    """
    input: DeleteFlatRateFulfillmentRestrictionInput!
  ): DeleteFlatRateFulfillmentRestrictionPayload!

  """
  Delete a MediaRecord to delete both the record and the backing file data
  """
  deleteMediaRecord(
    """
    Mutation input
    """
    input: DeleteMediaRecordInput!
  ): DeleteMediaRecordPayload!

  """
  Delete a navigation item
  """
  deleteNavigationItem(
    """
    Mutation input
    """
    input: DeleteNavigationItemInput!
  ): DeleteNavigationItemPayload

  """
  Delete a flat rate fulfillment restriction
  """
  deleteSurcharge(
    """
    Mutation input
    """
    input: DeleteSurchargeInput!
  ): DeleteSurchargePayload!

  """
  Delete a tax rate
  """
  deleteTaxRate(
    """
    Mutation input
    """
    input: DeleteTaxRateInput!
  ): DeleteTaxRatePayload

  """
  A test mutation that returns whatever string you send it
  """
  echo(
    """
    Any string
    """
    str: String
  ): String

  """
  Enable a payment method for a shop
  """
  enablePaymentMethodForShop(
    """
    Mutation input
    """
    input: EnablePaymentMethodForShopInput!
  ): EnablePaymentMethodForShopPayload!

  """
  Generate sitemap documents
  """
  generateSitemaps(
    """
    Mutation input
    """
    input: GenerateSitemapsInput
  ): GenerateSitemapsPayload!

  """
  Grant admin UI access for shops to a specific users
  """
  grantAdminUIAccess(
    input: GrantOrRevokeAdminUIAccessInput!
  ): GrantOrRevokeAdminUIAccessPayload!
  impersonate(
    accessToken: String!
    impersonated: ImpersonationUserIdentityInput!
  ): ImpersonateReturn

  """
  Given a person's email address and name, invite them to create an account for a certain shop,
  and put them in the provided permission group
  """
  inviteShopMember(
    """
    Mutation input
    """
    input: InviteShopMemberInput!
  ): InviteShopMemberPayload
  logout: Boolean

  """
  Use this mutation to move one or more items between existing order fulfillment groups.
  """
  moveOrderItems(
    """
    Mutation input
    """
    input: MoveOrderItemsInput!
  ): MoveOrderItemsPayload!

  """
  Use this mutation to place an order, providing information necessary to pay for it.
  The order will be placed only if authorization is successful for all submitted payments.
  """
  placeOrder(
    """
    Mutation input
    """
    input: PlaceOrderInput!
  ): PlaceOrderPayload!

  """
  Publish the draft structure for a navigation tree and the draft changes for all of its navigation items. Sets hasUnpublishedChanges to false on tree and its items
  """
  publishNavigationChanges(
    """
    Mutation input
    """
    input: PublishNavigationChangesInput!
  ): PublishNavigationChangesPayload

  """
  Publish products to the Catalog collection by product ID
  """
  publishProductsToCatalog(
    """
    Array of Product ID
    """
    productIds: [ID]!
  ): [CatalogItemProduct]

  """
  Force recalculation of the system-managed `inventoryReserved` field based on current order statuses
  """
  recalculateReservedSimpleInventory(
    """
    Mutation input
    """
    input: RecalculateReservedSimpleInventoryInput!
  ): RecalculateReservedSimpleInventoryPayload!

  """
  Reconcile an anonymous cart with the current account cart for the same shop
  """
  reconcileCarts(
    """
    Mutation input
    """
    input: ReconcileCartsInput!
  ): ReconcileCartsPayload!
  refreshTokens(accessToken: String!, refreshToken: String!): LoginResult

  """
  Remove an address from the `addressBook` field for an account
  """
  removeAccountAddressBookEntry(
    """
    Mutation input
    """
    input: RemoveAccountAddressBookEntryInput!
  ): RemoveAccountAddressBookEntryPayload

  """
  Remove an email address from an account
  """
  removeAccountEmailRecord(
    """
    Mutation input
    """
    input: RemoveAccountEmailRecordInput!
  ): RemoveAccountEmailRecordPayload

  """
  Remove an account from a group
  """
  removeAccountFromGroup(
    """
    Mutation input
    """
    input: RemoveAccountFromGroupInput!
  ): RemoveAccountFromGroupPayload

  """
  Remove an existing account group
  """
  removeAccountGroup(
    """
    Mutation input
    """
    input: RemoveAccountGroupInput!
  ): RemoveAccountGroupPayload

  """
  Remove item(s) from a cart
  """
  removeCartItems(
    """
    Mutation input
    """
    input: RemoveCartItemsInput!
  ): RemoveCartItemsPayload!

  """
  Remove a discount code from a cart
  """
  removeDiscountCodeFromCart(
    """
    Mutation input
    """
    input: RemoveDiscountCodeFromCartInput!
  ): RemoveDiscountCodeFromCartPayload!

  """
  Removes an existing tag
  """
  removeTag(
    """
    Mutation input
    """
    input: RemoveTagInput!
  ): RemoveTagPayload!

  """
  Bulk operation for removing an array of tags from an array of products
  """
  removeTagsFromProducts(
    """
    input which must includes an array of product ids and an array of tag ids
    """
    input: ProductTagsOperationInput!
  ): ProductTagsOperationPayload!
  resetPassword(newPassword: String!, token: String!): LoginResult

  """
  Retry a failed or cancelled email job
  """
  retryFailedEmail(
    """
    Mutation input
    """
    input: RetryFailedEmailInput!
  ): RetryFailedEmailPayload!

  """
  Revoke admin UI access to shops for specific users
  """
  revokeAdminUIAccess(
    input: GrantOrRevokeAdminUIAccessInput!
  ): GrantOrRevokeAdminUIAccessPayload!

  """
  Select a fulfillment option from the `availableFulfillmentOptions` list for a fulfillment group
  """
  selectFulfillmentOptionForGroup(
    """
    Mutation input
    """
    input: SelectFulfillmentOptionForGroupInput!
  ): SelectFulfillmentOptionForGroupPayload!

  """
  Send a reset password email to an email address from an account
  """
  sendResetAccountPasswordEmail(
    """
    Mutation input
    """
    input: SendResetAccountPasswordEmailInput!
  ): SendResetAccountPasswordEmailPayload
  sendResetPasswordEmail(email: String!): Boolean
  sendVerificationEmail(email: String!): Boolean

  """
  Set default email address for an account
  """
  setAccountDefaultEmail(
    """
    Mutation input
    """
    input: SetAccountDefaultEmailInput!
  ): SetAccountDefaultEmailPayload

  """
  Set the email address for an anonymous cart
  """
  setEmailOnAnonymousCart(
    """
    Mutation input
    """
    input: SetEmailOnAnonymousCartInput!
  ): SetEmailOnAnonymousCartPayload!

  """
  Set the shipping address for all fulfillment groups
  """
  setShippingAddressOnCart(
    """
    Mutation input
    """
    input: SetShippingAddressOnCartInput!
  ): SetShippingAddressOnCartPayload!

  """
  Add an image to the tag
  """
  setTagHeroMedia(
    """
    Mutation input
    """
    input: SetTagHeroMediaInput!
  ): SetTagHeroMediaPayload!

  """
  Use this mutation to reduce the quantity of one item of an order and create
  a new item for the remaining quantity in the same fulfillment group, and with the
  same item status. You may want to do this if you are only able to partially fulfill
  the item order right now.
  """
  splitOrderItem(
    """
    Mutation input
    """
    input: SplitOrderItemInput!
  ): SplitOrderItemPayload!
  twoFactorSet(code: String!, secret: TwoFactorSecretKeyInput!): Boolean
  twoFactorUnset(code: String!): Boolean

  """
  Update account fields
  """
  updateAccount(
    """
    Mutation input
    """
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  """
  Remove an address that exists in the `addressBook` field for an account
  """
  updateAccountAddressBookEntry(
    """
    Mutation input
    """
    input: UpdateAccountAddressBookEntryInput!
  ): UpdateAccountAddressBookEntryPayload

  """
  Update an existing account group
  """
  updateAccountGroup(
    """
    Mutation input
    """
    input: UpdateAccountGroupInput!
  ): UpdateAccountGroupPayload

  """
  Update an address validation rule
  """
  updateAddressValidationRule(
    """
    Mutation input
    """
    input: UpdateAddressValidationRuleInput!
  ): UpdateAddressValidationRulePayload!

  """
  Update admin UI access to shops for specific users
  """
  updateAdminUIAccess(
    input: UpdateAdminUIAccessInput!
  ): UpdateAdminUIAccessPayload!

  """
  Update cart item(s) quantity. Use absolute quantity. If updating to 0, the item will be removed.
  """
  updateCartItemsQuantity(
    """
    Mutation input
    """
    input: UpdateCartItemsQuantityInput!
  ): UpdateCartItemsQuantityPayload!

  """
  Update a discount code
  """
  updateDiscountCode(
    """
    Mutation input
    """
    input: UpdateDiscountCodeInput!
  ): UpdateDiscountCodePayload

  """
  Update a flat rate fulfillment method
  """
  updateFlatRateFulfillmentMethod(
    """
    Mutation input
    """
    input: UpdateFlatRateFulfillmentMethodInput!
  ): UpdateFlatRateFulfillmentMethodPayload!

  """
  Update a flat rate fulfillment method restriction
  """
  updateFlatRateFulfillmentRestriction(
    """
    Mutation input
    """
    input: UpdateFlatRateFulfillmentRestrictionInput!
  ): UpdateFlatRateFulfillmentRestrictionPayload!

  """
  Clients should call this as necessary during checkout to update the `availableFulfillmentOptions`
  property for all fulfillment groups of the cart with fresh price quotes. These need to be
  recalculated every time the items in that group change. When the order is placed, the chosen
  option for each group will have its prices recalculated one last time. If the prices do not match,
  order creation will fail.
  """
  updateFulfillmentOptionsForGroup(
    """
    Mutation input
    """
    input: UpdateFulfillmentOptionsForGroupInput!
  ): UpdateFulfillmentOptionsForGroupPayload!

  """
  Returns app settings that are not shop specific. Plugins extend the GlobalSettings type to support
  whatever settings they need.
  """
  updateGlobalSettings(
    """
    Mutation input
    """
    input: UpdateGlobalSettingsInput!
  ): UpdateGlobalSettingsPayload!

  """
  Bulk-update groups for accounts
  """
  updateGroupsForAccounts(
    """
    Mutation input
    """
    input: UpdateGroupsForAccountsInput!
  ): UpdateGroupsForAccountsPayload

  """
  Update the priority metadata for a MediaRecord. Used for sorting product and variant media in the catalog.
  """
  updateMediaRecordPriority(
    """
    Mutation input
    """
    input: UpdateMediaRecordPriorityInput!
  ): UpdateMediaRecordPriorityPayload!

  """
  Update an existing navigation item's draft data. Sets hasUnpublishedChanges to true
  """
  updateNavigationItem(
    """
    Mutation input
    """
    input: UpdateNavigationItemInput!
  ): UpdateNavigationItemPayload

  """
  Update an existing navigation tree's draft items. Sets hasUnpublishedChanges to true
  """
  updateNavigationTree(
    """
    Mutation input
    """
    input: UpdateNavigationTreeInput!
  ): UpdateNavigationTreePayload

  """
  Use this mutation to update order details after the order has been placed.
  """
  updateOrder(
    """
    Mutation input
    """
    input: UpdateOrderInput!
  ): UpdateOrderPayload!

  """
  Use this mutation to update an order fulfillment group status and tracking information.
  """
  updateOrderFulfillmentGroup(
    """
    Mutation input
    """
    input: UpdateOrderFulfillmentGroupInput!
  ): UpdateOrderFulfillmentGroupPayload!

  """
  Update an existing product
  """
  updateProduct(
    """
    Mutation input
    """
    input: UpdateProductInput!
  ): UpdateProductPayload!

  """
  Update an existing product variant
  """
  updateProductVariant(
    """
    Mutation input
    """
    input: UpdateProductVariantInput!
  ): UpdateProductVariantPayload!

  """
  Update an existing product variants prices
  """
  updateProductVariantPrices(
    """
    Mutation input
    """
    input: UpdateProductVariantPricesInput!
  ): UpdateProductVariantPricesPayload!

  """
  Update the isVisible property of an array of products
  """
  updateProductsVisibility(
    """
    Mutation input
    """
    input: UpdateProductsVisibilityInput!
  ): UpdateProductsVisibilityPayload!

  """
  Given shop data, update the Shops collection with this data
  """
  updateShop(
    """
    Mutation input
    """
    input: UpdateShopInput!
  ): UpdateShopPayload!

  """
  Returns app settings for a specific shop. Plugins extend the ShopSettings type to support
  whatever settings they need.
  """
  updateShopSettings(
    """
    Mutation input
    """
    input: UpdateShopSettingsInput!
  ): UpdateShopSettingsPayload!

  """
  Update the SimpleInventory info for a product configuration
  """
  updateSimpleInventory(
    """
    Mutation input
    """
    input: UpdateSimpleInventoryInput!
  ): UpdateSimpleInventoryPayload!

  """
  Update a flat rate fulfillment surcharge
  """
  updateSurcharge(
    """
    Mutation input
    """
    input: UpdateSurchargeInput!
  ): UpdateSurchargePayload!

  """
  Updates an existing tag
  """
  updateTag(
    """
    Mutation input
    """
    input: UpdateTagInput!
  ): UpdateTagPayload!

  """
  Update a tax rate
  """
  updateTaxRate(
    """
    Mutation input
    """
    input: UpdateTaxRateInput!
  ): UpdateTaxRatePayload

  """
  Updates an existing template
  """
  updateTemplate(
    """
    Mutation input
    """
    input: UpdateTemplateInput!
  ): UpdateTemplatePayload!
  verifyAuthentication(
    params: AuthenticateParamsInput!
    serviceName: String!
  ): Boolean
  verifyEmail(token: String!): Boolean

  """
  Use this mutation to verify the SMTP email settings
  """
  verifySMTPEmailSettings(
    """
    Mutation input
    """
    input: VerifySMTPEmailSettingsInput!
  ): VerifySMTPEmailSettingsInputPayload!
}

"""
Represents a single navigation item
"""
type NavigationItem implements Node {
  """
  The navigation item ID
  """
  _id: ID!

  """
  The date and time at which this navigation item was created
  """
  createdAt: DateTime!

  """
  The published data for this navigation item
  """
  data: NavigationItemData

  """
  The draft/unpublished data for this navigation item
  """
  draftData: NavigationItemData

  """
  Whether the navigation item has unpublished changes
  """
  hasUnpublishedChanges: Boolean

  """
  An object storing additional metadata about the navigation item (such as its related tag)
  """
  metadata: JSONObject

  """
  The ID of the shop the navigation item belongs to
  """
  shopId: ID!
}

"""
Wraps a list of `NavigationItem`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type NavigationItemConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [NavigationItemEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [NavigationItem]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
Represents the translated content for a navigation item
"""
type NavigationItemContent {
  """
  The language of the piece of navigation content
  """
  language: String!

  """
  The translated value, in plain text or markdown
  """
  value: String
}

"""
NavigationItem content input
"""
input NavigationItemContentInput {
  """
  The language of the piece of navigation content
  """
  language: String!

  """
  The translated value, in plain text or markdown
  """
  value: String
}

"""
Represents the data for a navigation item
"""
type NavigationItemData {
  """
  CSS class names to add to the menu item for display
  """
  classNames: String

  """
  The content for the navigation item, in one or more languages
  """
  content: [NavigationItemContent]

  """
  The translated content for a navigation item
  """
  contentForLanguage: String

  """
  Whether the provided URL is relative or external
  """
  isUrlRelative: Boolean

  """
  Whether the navigation item should trigger a new tab/window to open when clicked
  """
  shouldOpenInNewWindow: Boolean

  """
  The URL for the navigation item to link to
  """
  url: String
}

"""
NavigationItemData input
"""
input NavigationItemDataInput {
  """
  CSS class names to add to the menu item for display
  """
  classNames: String

  """
  The content for the navigation item, in one or more languages
  """
  content: [NavigationItemContentInput]

  """
  Whether the provided URL is relative or external
  """
  isUrlRelative: Boolean

  """
  Whether the navigation item should trigger a new tab/window to open when clicked
  """
  shouldOpenInNewWindow: Boolean

  """
  The URL for the navigation item to link to
  """
  url: String
}

"""
A connection edge in which each node is a `NavigationItem` object
"""
type NavigationItemEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The navigation item
  """
  node: NavigationItem
}

"""
NavigationItem input
"""
input NavigationItemInput {
  """
  The draft/unpublished data for this navigation item
  """
  draftData: NavigationItemDataInput

  """
  An object storing additional metadata about the navigation item (such as its related tag)
  """
  metadata: JSONObject

  """
  Shop ID of the navigation item
  """
  shopId: ID!
}

"""
The fields by which you are allowed to sort any query that returns a `NavigationItemConnection`
"""
enum NavigationItemSortByField {
  """
  Sort by NavigationItem ID
  """
  _id

  """
  Sort by when the NavigationItem was created
  """
  createdAt
}

"""
Represents a navigation tree containing multiple levels of navigation items
"""
type NavigationTree implements Node {
  """
  The navigation tree ID
  """
  _id: ID!

  """
  The draft navigation items that make up this tree
  """
  draftItems: [NavigationTreeItem]

  """
  Whether the navigation item has unpublished changes
  """
  hasUnpublishedChanges: Boolean

  """
  The published navigation items that make up this tree
  """
  items: [NavigationTreeItem]

  """
  The name of the tree, for operator display purposes. Assumed to be in the primary shop's language
  """
  name: String!

  """
  The ID of the shop this navigation tree belongs to
  """
  shopId: ID!
}

"""
NavigationTree input
"""
input NavigationTreeInput {
  """
  The draft navigation items that make up this tree
  """
  draftItems: [NavigationTreeItemInput]

  """
  The name of the tree, for operator display purposes
  """
  name: String
}

"""
Represents a navigation item and its children in a tree
"""
type NavigationTreeItem {
  """
  Whether the navigation item should display its children
  """
  expanded: Boolean

  """
  Whether the navigation item should be hidden from customers
  """
  isPrivate: Boolean

  """
  Whether the navigaton item is a secondary navigation item
  """
  isSecondary: Boolean

  """
  Whether the navigation ttem should shown in query results for customers and admins
  """
  isVisible: Boolean

  """
  The child navigation items
  """
  items: [NavigationTreeItem]

  """
  The navigation item
  """
  navigationItem: NavigationItem!
}

"""
NavigationTree item input
"""
input NavigationTreeItemInput {
  """
  Whether the navigation item should display its children
  """
  expanded: Boolean

  """
  Whether the navigation item should be hidden from customers
  """
  isPrivate: Boolean

  """
  Whether the navigaton item is a secondary navigation item
  """
  isSecondary: Boolean

  """
  Whether the navigation ttem should shown in query results for customers and admins
  """
  isVisible: Boolean

  """
  The child navigation items
  """
  items: [NavigationTreeItemInput]

  """
  The ID of the navigation item
  """
  navigationItemId: ID!
}

"""
Objects implementing the Node interface will always have an _id field that is globally unique.
"""
interface Node {
  """
  The ID of the object
  """
  _id: ID!
}

"""
Objects implementing the NodeEdge interface will always have a node and a cursor
that represents that node for purposes of requesting paginated results.
"""
interface NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The node itself
  """
  node: Node
}

"""
An order
"""
type Order implements Node {
  """
  The Order ID
  """
  _id: ID!

  """
  The account that placed the order. Some orders are created for anonymous users. Anonymous orders have a null account.
  """
  account: Account

  """
  Full name(s) involved with payment. Payment can be made by one or more than one person
  """
  billingName: String

  """
  The ID of the cart that created this order. Carts are deleted after becoming orders, so this is just a reference.
  """
  cartId: ID

  """
  The date and time at which the cart was created, which is when the first item was added to it.
  """
  createdAt: DateTime!

  """
  The order status for display in UI
  """
  displayStatus(
    """
    The language in which you want the status. If no translation is available for this language,
    it will be in the default language of the shop that owns the order.
    """
    language: String!
  ): String!

  """
  An email address that has been associated with the cart
  """
  email: String

  """
  One or more fulfillment groups. Each of these are fulfilled and charged as separate orders.
  """
  fulfillmentGroups: [OrderFulfillmentGroup]!

  """
  Notes about the order. This will always return an array but it may be empty
  """
  notes: [OrderNote]!

  """
  Payments that collectively have paid or will pay for the total amount due for this order.
  May be null if no payment is needed.
  """
  payments: [Payment]

  """
  An ID by which the customer can reference this order when enquiring about it. A storefront user
  interface may show this to customers. Do not display other IDs (`_id`) to customers.
  """
  referenceId: String!

  """
  Refunds that have been applied to the payments on this order.
  """
  refunds: [Refund]

  """
  The shop through which the order was placed
  """
  shop: Shop!

  """
  The machine-readable order status.
  """
  status: String!

  """
  A summary of the totals for all fulfillment groups for this order
  """
  summary: OrderSummary!

  """
  Surcharges applied to this order
  """
  surcharges: [AppliedSurcharge]!

  """
  Total quantity of all items in the order
  """
  totalItemQuantity: Int!

  """
  The date and time at which this order was last updated
  """
  updatedAt: DateTime!
}

"""
Wraps a list of `Order`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type OrderConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [OrderEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Order]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `Order` object
"""
type OrderEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The order
  """
  node: Order
}

"""
Input type for filters to by applied to an Orders list
"""
input OrderFilterInput {
  """
  A createdAt date range to filter by
  """
  createdAt: CreatedAtInput

  """
  An order's fulfillment status
  """
  fulfillmentStatus: [OrderFulfillmentStatus]

  """
  An order's payment status
  """
  paymentStatus: [OrderPaymentStatus]

  """
  Keywords typed by the user in the search input field
  """
  searchField: String

  """
  The order's status to filter by
  """
  status: OrderStatus
}

"""
An order fulfillment group
"""
type OrderFulfillmentGroup implements Node {
  """
  The order fulfillment group ID
  """
  _id: ID!

  """
  Information needed by the selected fulfillment method to properly fulfill the order
  """
  data: OrderFulfillmentGroupData

  """
  The order status for display in UI
  """
  displayStatus(
    """
    The language in which you want the status. If no translation is available for this language,
    it will be in the default language of the shop that owns the order.
    """
    language: String!
  ): String!

  """
  The items that are part of this fulfillment group
  """
  items(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, order items are sorted by when they were added to the order, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: OrderFulfillmentGroupItemsSortByField = addedAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): OrderItemConnection

  """
  The fulfillment method that was selected, with its price quote
  """
  selectedFulfillmentOption: FulfillmentOption!

  """
  The shipping label URL
  """
  shippingLabelUrl: String

  """
  The shop responsible for fulfilling this order
  """
  shop: Shop!

  """
  The machine-readable fulfillment group status.
  """
  status: String!

  """
  A summary of the totals for this group
  """
  summary: OrderSummary!

  """
  A summary of calculated taxes for this group.
  """
  taxSummary: TaxSummary

  """
  Total quantity of all items in the group
  """
  totalItemQuantity: Int!

  """
  The order fulfillment group shipment tracking number
  """
  tracking: String

  """
  The order fulfillment group shipment tracking URL
  """
  trackingUrl: String

  """
  The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  """
  type: FulfillmentType!
}

"""
Extra data for an order fulfillment group
"""
union OrderFulfillmentGroupData = ShippingOrderFulfillmentGroupData

"""
Information needed by the selected fulfillment method to properly fulfill the order
"""
input OrderFulfillmentGroupDataInput {
  """
  The mailing address to which this fulfillment group should be shipped
  """
  shippingAddress: AddressInput
}

"""
Similar to `OrderFulfillmentGroupInput` but `items` can be omitted if moving existing items to the new group
"""
input OrderFulfillmentGroupExistingOrderInput {
  """
  Information needed by the selected fulfillment method to properly fulfill the order
  """
  data: OrderFulfillmentGroupDataInput

  """
  The list of items to be ordered
  """
  items: [OrderFulfillmentGroupItemInput]

  """
  The ID of the fulfillment method to be used for this order group
  """
  selectedFulfillmentMethodId: ID!

  """
  The shop that owns these items and needs to fulfill this part of the order
  """
  shopId: ID!

  """
  The total price of the items, fulfillment, and taxes, for this group, less any discounts, in the
  `order.currencyCode` currency. This value is not trusted; the actual total is calculated by the
  Order service. However, providing this value prevents an order being created for an amount that
  does not match what was shown to the shopper in order preview.
  """
  totalPrice: Float

  """
  The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  """
  type: FulfillmentType!
}

"""
Input for an `OrderFulfillmentGroup`
"""
input OrderFulfillmentGroupInput {
  """
  Information needed by the selected fulfillment method to properly fulfill the order
  """
  data: OrderFulfillmentGroupDataInput

  """
  The list of items to be ordered
  """
  items: [OrderFulfillmentGroupItemInput]!

  """
  The ID of the fulfillment method to be used for this order group
  """
  selectedFulfillmentMethodId: ID!

  """
  The shop that owns these items and needs to fulfill this part of the order
  """
  shopId: ID!

  """
  The total price of the items, fulfillment, and taxes, for this group, less any discounts, in the
  `order.currencyCode` currency. This value is not trusted; the actual total is calculated by the
  Order service. However, providing this value prevents an order being created for an amount that
  does not match what was shown to the shopper in order preview.
  """
  totalPrice: Float

  """
  The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  """
  type: FulfillmentType!
}

"""
Input for an `OrderFulfillmentGroupItem`
"""
input OrderFulfillmentGroupItemInput {
  """
  The date and time at which this item was first added to the source cart, if this is something you want to track
  """
  addedAt: DateTime

  """
  The price of the item, in the `order.currencyCode` currency. This value is not trusted; the actual price
  is confirmed by the Order service. However, providing this value prevents an order being created for an
  amount that does not match what was shown to the shopper in order preview.
  """
  price: Float!

  """
  The product and chosen options
  """
  productConfiguration: ProductConfigurationInput!

  """
  The desired quantity of this item. This must be a positive integer.
  """
  quantity: Int!
}

"""
Allowed values for the `OrderFulfillmentGroupItems` sortBy parameter
"""
enum OrderFulfillmentGroupItemsSortByField {
  """
  Sort by the item ID
  """
  _id

  """
  Sort by the date and time when the item was added to the order
  """
  addedAt
}

"""
Available order fulfillment statuses
"""
enum OrderFulfillmentStatus {
  """
  An order that has been completed
  """
  completed

  """
  Newly created order that needs processing
  """
  new

  """
  An order that is currently being processed
  """
  processing
}

"""
Input for placing an order
"""
input OrderInput {
  """
  The ID of the cart that is becoming an order. This is optional, and you can create an order without ever
  creating a cart. If you do have a cart, there are two good reasons to provide this. First, it serves as a
  reference. Second, it allows the Cart service to automatically delete the related cart after the order is
  created.
  """
  cartId: String

  """
  The code for the currency in which all values are being provided
  """
  currencyCode: String!

  """
  An email address to use for order tracking and correspondence. If a logged in user is placing an order,
  we recommend that you use their "orders" email address, if they have one, or their default email address.
  Or you can ask them to provide any email address.
  """
  email: String!

  """
  One or more fulfillment groups for the order. These are the actual orders that need to be fulfilled,
  separate by shop, fulfillment type, and shipping origin or destination.
  """
  fulfillmentGroups: [OrderFulfillmentGroupInput]!

  """
  The shop through which the order should be placed. Payment settings from this shop will be used. Note that
  each fulfillment group also has a shop ID, which represents the shop that needs to fulfill that part of the
  order, and those shop IDs may or may not match this one.
  """
  shopId: String!
}

"""
A single item in an order. The item contains information about a purchase.
"""
type OrderItem implements Node {
  """
  The order item ID
  """
  _id: ID!

  """
  "
  The date and time at which this item was first added to the associated cart.
  If an item is added, removed, and then added again, this will reflect the most recent addition.
  However, if an item is added twice, the quantity will increase but this date will remain
  the initial added date.
  """
  addedAt: DateTime

  """
  FUTURE. Additional attributes of the chosen item. For example, if this item is for a product, socks, where `blue` and `small`
  options were chosen for some configurable attributes, then `color:blue` and `size:small` will be indicated here.
  """
  attributes: [OrderItemAttribute]

  """
  If this order item is canceled, the reason for cancelation, if provided
  """
  cancelReason: String

  """
  The date and time at which the order item was created
  """
  createdAt: DateTime!

  """
  The URLs for a picture of the item in various sizes
  """
  imageURLs: ImageSizes

  """
  Is this a taxable item?
  """
  isTaxable: Boolean!

  """
  Arbitrary additional metadata about this cart item.
  """
  metafields: [Metafield]

  """
  The short title of the associated option, if this is an option item
  """
  optionTitle: String

  """
  Packing information such as item weight, height, length, and depth. Used for calculating shipping rates.
  """
  parcel: ShippingParcel

  """
  The price of the item at the time of purchase
  """
  price: Money!

  """
  The product and chosen options
  """
  productConfiguration: ProductConfiguration!

  """
  The product's slug
  """
  productSlug: String

  """
  The list of tags that have been applied to this product
  """
  productTags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = _id

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  The type of product, used to display cart items differently
  """
  productType: String

  """
  The product vendor
  """
  productVendor: String

  """
  The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item.
  """
  quantity: Int!

  """
  The shop associated with this cart item.
  """
  shop: Shop!

  """
  The machine-readable order item status.
  """
  status: String!

  """
  The price of the item multiplied by the quantity of this item ordered
  """
  subtotal: Money!

  """
  Total tax calculated for this item
  """
  tax: Money!

  """
  The tax code for this item
  """
  taxCode: String

  """
  Amount of subtotal that is taxable
  """
  taxableAmount: Money!

  """
  List of calculated taxes due for this item
  """
  taxes: [CalculatedTax]!

  """
  A title for use in orders that conveys the selected product's title + chosen options
  """
  title: String!

  """
  The date and time at which this item was last updated
  """
  updatedAt: DateTime!

  """
  The selected variant title
  """
  variantTitle: String
}

"""
One attribute of an order item
"""
type OrderItemAttribute {
  """
  The attribute label, e.g., Color
  """
  label: String

  """
  The attribute value, e.g., Blue
  """
  value: String
}

"""
Wraps a list of `OrderItem`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type OrderItemConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [OrderItemEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [OrderItem]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `OrderItem` object
"""
type OrderItemEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The order item
  """
  node: OrderItem
}

"""
A note about an order
"""
type OrderNote {
  """
  The account who wrote this note
  """
  account: Account!

  """
  The content of the note
  """
  content: String!

  """
  The date and time at which this note was created
  """
  createdAt: DateTime!

  """
  The date and time at which this note was last updated
  """
  updatedAt: DateTime!
}

"""
Order payment status
"""
enum OrderPaymentStatus {
  """
  Payments that have been successfully processed
  """
  completed

  """
  A payment intent has been created
  """
  created
}

"""
Order status
"""
enum OrderStatus {
  """
  Canceled order
  """
  canceled

  """
  A completed order
  """
  completed

  """
  A new order that needs processing
  """
  new

  """
  An order that is being processed
  """
  processing
}

"""
A summary of the totals for this order
"""
type OrderSummary {
  """
  The total of all discounts applied, as a positive number
  """
  discountTotal: Money!

  """
  The calculated tax-exclusive tax rate on all items and fulfillment prices (taxTotal / taxableAmount)
  """
  effectiveTaxRate: Rate!

  """
  The total price of all chosen fulfillment methods
  """
  fulfillmentTotal: Money!

  """
  The combined prices of all cart items
  """
  itemTotal: Money!

  """
  The total of all suurcharges applied
  """
  surchargeTotal: Money

  """
  The total estimated tax that has not already been included in the item prices
  """
  taxTotal: Money!

  """
  The total amount that was deemed taxable by the tax service
  """
  taxableAmount: Money!

  """
  The sum of `itemTotal`, `fulfillmentTotal`, and `taxTotal`, minus `discountTotal`
  """
  total: Money!
}

"""
Wraps a list of `Order`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type OrdersByAccountIdConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [OrdersByAccountIdEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Order]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `Order` object
"""
type OrdersByAccountIdEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The order
  """
  node: Order
}

"""
The fields by which you are allowed to sort any query that returns a `OrdersByAccountIdConnection`
"""
enum OrdersByAccountIdSortByField {
  """
  Sort by the order ID
  """
  _id

  """
  Sort by the date and time when the order was placed
  """
  createdAt
}

"""
The fields by which you are allowed to sort any query that returns a `OrderConnection`
"""
enum OrdersSortByField {
  """
  Sort by the order ID
  """
  _id

  """
  Sort by the date and time when the order was placed
  """
  createdAt
}

"""
Pagination information. When requesting pages of results, you can use endCursor or startCursor
as your before or after parameters for the query you are paging.
"""
type PageInfo {
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: ConnectionCursor

  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: ConnectionCursor
}

"""
Information about a payment made
"""
type Payment implements Node {
  """
  The Payment ID
  """
  _id: ID!

  """
  The amount that will be applied to this payment method. If there are multiple payment methods applied to the
  cart, this may be less than the cart total.
  """
  amount: Money!

  """
  The billing address for this payment, if one was collected
  """
  billingAddress: Address

  """
  If status is `error` due to a capture error, this code describes the error in a machine-readable way.
  """
  captureErrorCode: String

  """
  If status is `error` due to a capture error, this code describes the error in a human-readable way.
  """
  captureErrorMessage: String

  """
  For card payments, the brand of the card. Useful for showing card icons for common brands.
  """
  cardBrand: String

  """
  The date and time at which this payment was created
  """
  createdAt: DateTime!

  """
  The shopper-provided data needed to complete the payment using this method.
  For example, a billing address, store credit code, stored credit card ID, etc.
  """
  data: PaymentData

  """
  Use this identifier when showing this payment in a user interface
  """
  displayName: String!

  """
  Has the payment authorization been canceled?
  """
  isAuthorizationCanceled: Boolean!

  """
  Has the payment been captured? If false, it is just an authorization.
  """
  isCaptured: Boolean!

  """
  The payment method
  """
  method: PaymentMethod!

  """
  The payment mode
  """
  mode: String

  """
  The payment processor
  """
  processor: String

  """
  Refunds that have been applied to this payment.
  """
  refunds: [Refund]

  """
  Risk level of payment
  """
  riskLevel: RiskLevel

  """
  The current status of this payment
  """
  status: PaymentStatus!

  """
  The payment transaction ID
  """
  transactionId: String
}

"""
Data identifying a payment for an order
"""
union PaymentData = ExampleIOUPaymentData | FakeData | StripePaymentIntentData

"""
Input for adding order payments
"""
input PaymentInput {
  """
  Amount to charge, which must be less than or equal to the order total. This is assumed
  to be in the same currency as the order. Set to `null` to charge the remaining amount
  to this payment method, which might be the full order total if this is the only payment.
  """
  amount: Float!

  """
  The billing address entered by the shopper. If omitted, the billing address on the order input
  will be used. Some payment methods may not require a billing address but others will fail
  authorization without one, so be sure that client UI code is aware of which payment methods
  require collecting one.
  """
  billingAddress: AddressInput

  """
  Any additional user-provided input necessary to authorize and capture the payment
  """
  data: JSONObject

  """
  The name of the payment method to use for this payment
  """
  method: PaymentMethodName!
}

"""
Describes a payment method
"""
type PaymentMethod {
  """
  If this is `false`, the payment method does not support refunding. Use this to hide refund UI.
  """
  canRefund: Boolean!

  """
  Data for this method. The data format differs for each method
  """
  data: PaymentMethodData

  """
  Human-readable display name
  """
  displayName: String!

  """
  Whether the payment method is enabled on a given shop
  """
  isEnabled: Boolean!

  """
  The payment method name. Any valid name that has been registered by a payment plugin. e.g., saved_card
  """
  name: String!

  """
  Name of the plugin that added the payment method
  """
  pluginName: String!
}

"""
Any extra data needed by the payment method
"""
union PaymentMethodData = ExampleIOUPaymentMethodData | FakeData

"""
The name of a payment method, which is how payment methods are keyed
"""
enum PaymentMethodName {
  """
  IOU Example payment method
  """
  iou_example

  """
  No payment method
  """
  none

  """
  Stripe payment method
  """
  stripe_payment_intent
}

"""
Valid payment statuses
"""
enum PaymentStatus {
  """
  A shop operator adjusted the payment amount after the order was placed
  """
  adjustments

  """
  A shop operator has approved this payment
  """
  approved

  """
  A shop operator has canceled this payment before it was captured
  """
  canceled

  """
  A shop operator has captured this payment
  """
  completed

  """
  Upon placing an order, the status of all payments for that order begins at 'created'
  """
  created

  """
  There was an error capturing the payment
  """
  error

  """
  A shop operator has refunded some but not all of this payment
  """
  partialRefund

  """
  A shop operator has refunded all of this payment
  """
  refunded
}

"""
Input for the placeOrder mutation
"""
input PlaceOrderInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The order to be placed, if payment is accepted
  """
  order: OrderInput!

  """
  The information necessary to pay. Collect this information from the shopper during a checkout flow.
  You need not provide any payment input if the total is zero.
  The total of all payment input `amount` fields must add up to the order total. The first payment
  method where the `amount` field is `null` will be charged the remainder due.
  """
  payments: [PaymentInput]
}

"""
Response payload for the placeOrder mutation
"""
type PlaceOrderPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Orders that were created
  """
  orders: [Order]!

  """
  If you are not logged in, this will be a token that can be used for future requests
  """
  token: String
}

"""
Represents Reaction Plugin
"""
type Plugin {
  """
  Name of plugin
  """
  name: String!

  """
  Version of plugin
  """
  version: String
}

"""
A Reaction product
"""
type Product {
  """
  Product ID
  """
  _id: ID!

  """
  The date and time at which this product was created
  """
  createdAt: DateTime!

  """
  Hash to compare with publishedProductHash, to see if this product has changed since it was last published
  """
  currentProductHash: String

  """
  The full product description, which may have newline characters in it
  """
  description: String

  """
  True if this product has been deleted. Typically, deleted products are not returned in queries.
  """
  isDeleted: Boolean!

  """
  True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  """
  isVisible: Boolean!

  """
  All media for a product
  """
  media(
    """
    Determines whether variant media should be included in the product or not
    """
    shouldIncludeVariantMedia: Boolean = true
  ): [ImageInfo]

  """
  The product description to use for page `description` meta element in HTML
  """
  metaDescription: String

  """
  Arbitrary additional metadata about this product
  """
  metafields: [Metafield]!

  """
  The country of origin
  """
  originCountry: String

  """
  Subtitle
  """
  pageTitle: String

  """
  Price range
  """
  price: ProductPriceRange @deprecated(reason: "Use `pricing`")

  """
  Pricing information
  """
  pricing: ProductPricingInfo!

  """
  An arbitrary product type value, such as from an external system
  """
  productType: String

  """
  The date and time at which this product was last published. If `null`, it has never been published.
  """
  publishedAt: DateTime

  """
  Hash to compare with currentProductHash, to see if this product has changed since it was last published
  """
  publishedProductHash: String

  """
  The shop to which this product belongs
  """
  shop: Shop!

  """
  Whether this product will be shown in the generated sitemap
  """
  shouldAppearInSitemap: Boolean

  """
  A URL-safe and human-readable string that uniquely identifies this product
  """
  slug: String

  """
  Holds metadata specific to a specific social network service
  """
  socialMetadata: [SocialMetadata]

  """
  When a shopper purchases this product, what types of fulfillment can they choose from?
  """
  supportedFulfillmentTypes: [FulfillmentType]!

  """
  The list of tag IDs that have been applied to this product
  """
  tagIds: [ID]

  """
  The list of tags that have been applied to this product
  """
  tags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = _id

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  Product title
  """
  title: String

  """
  The date and time at which this product was last updated
  """
  updatedAt: DateTime

  """
  A list of all variants for this product
  """
  variants(
    """
    Include archived variants
    """
    shouldIncludeArchived: Boolean = false

    """
    Include hidden variants
    """
    shouldIncludeHidden: Boolean = true
  ): [ProductVariant]!

  """
  The product vendor or manufacturer, for display
  """
  vendor: String
}

"""
Product configuration data
"""
type ProductConfiguration {
  """
  The Product ID
  """
  productId: ID!

  """
  The ProductVariant ID
  """
  productVariantId: ID!
}

"""
Input that defines a single configuration of a product
"""
input ProductConfigurationInput {
  """
  The Product ID
  """
  productId: ID!

  """
  The ProductVariant ID
  """
  productVariantId: ID!
}

"""
Wraps a list of Products`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type ProductConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [ProductEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Product]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
Operators for filtering on a DateTime field
"""
input ProductDateOperators {
  """
  The value must be greater than or equal to the given value
  """
  after: DateTime

  """
  The value must be greater than the given value
  """
  before: DateTime

  """
  The value must be between the given values
  """
  between: ProductDateRange

  """
  The value must be equal to the given value
  """
  eq: DateTime
}

"""
Range operator for DateTime fields
"""
input ProductDateRange {
  """
  The end of the date range
  """
  end: DateTime!

  """
  The start of the date range
  """
  start: DateTime!
}

"""
A connection edge in which each node is a `Product` object
"""
type ProductEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The product
  """
  node: Product
}

"""
Mutation input for a product
"""
input ProductInput {
  """
  Any string to use as the internal ID for a new product. Do not prefix or base64 encode this ID.
  This field is allowed only when creating a product. If you include an ID for an update, you
  will get an error. The string must also be different from any existing product, variant, or
  option internal ID or you will get a duplicate ID error. If you do not include this when creating
  a product, a random unique string is generated for you.
  """
  _id: String

  """
  The full product description, which may have newline characters in it
  """
  description: String

  """
  Facebook message
  """
  facebookMsg: String

  """
  Google message
  """
  googleplusMsg: String

  """
  True if this product has been deleted. Typically, deleted products are not returned in queries.
  """
  isDeleted: Boolean

  """
  True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  """
  isVisible: Boolean

  """
  The product description to use for page `description` meta element in HTML
  """
  metaDescription: String

  """
  Arbitrary additional metadata about this product
  """
  metafields: [MetafieldInput]

  """
  The country of origin
  """
  originCountry: String

  """
  Subtitle
  """
  pageTitle: String

  """
  Pinterest message
  """
  pinterestMsg: String

  """
  An arbitrary product type value, such as from an external system
  """
  productType: String

  """
  Whether this product will be shown in the generated sitemap
  """
  shouldAppearInSitemap: Boolean

  """
  A URL-safe and human-readable string that uniquely identifies this product
  """
  slug: String

  """
  When a shopper purchases this product, what types of fulfillment can they choose from?
  """
  supportedFulfillmentTypes: [FulfillmentType]

  """
  The list of tag IDs that have been applied to this product
  """
  tagIds: [ID]

  """
  Product title
  """
  title: String

  """
  Twitter message
  """
  twitterMsg: String

  """
  The product vendor or manufacturer, for display
  """
  vendor: String
}

"""
Product price range
"""
type ProductPriceRange {
  """
  Maximum price in range
  """
  max: Float

  """
  Minimum price in range
  """
  min: Float

  """
  Price range display
  """
  range: String
}

"""
The product price or price range for a specific currency
"""
type ProductPricingInfo {
  """
  A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  only purchasable variants will have a `compareAtPrice`.
  """
  compareAtPrice: Money

  """
  The code for the currency these pricing details applies to
  """
  currency: Currency!

  """
  Pricing converted to specified currency
  """
  currencyExchangePricing(
    """
    Code for the currency in which you want to see pricing info
    """
    currencyCode: String!
  ): CurrencyExchangeProductPricingInfo

  """
  UI should display this price. If a product has multiple potential prices depending on selected
  variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  symbols.
  """
  displayPrice: String!

  """
  The price of the most expensive possible variant+option combination
  """
  maxPrice: Float!

  """
  The price of the least expensive possible variant+option combination
  """
  minPrice: Float!

  """
  For variants with no options and for options, this will always be set to a price. For variants
  with options and products, this will be `null`. There must be a price for a variant to be
  added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  """
  price: Float
}

"""
The fields by which you are allowed to sort any query that returns a `ProductConnection`
"""
enum ProductSortByField {
  """
  Product ID
  """
  _id

  """
  Date and time the product was created
  """
  createdAt

  """
  Product title
  """
  title

  """
  Date and time the product was last updated
  """
  updatedAt
}

"""
Input for adding tags to products in bulk
"""
input ProductTagsOperationInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  An array of product productIds to which an array of tags will be added
  """
  productIds: [ID]

  """
  The shop id
  """
  shopId: ID!

  """
  An array of tag ids to add to an array of products
  """
  tagIds: [ID]
}

"""
Response payload managing tags on products
"""
type ProductTagsOperationPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The number of products found
  """
  foundCount: Int

  """
  The number of products for which a match was not found
  """
  notFoundCount: Int

  """
  The number of products successfully updated
  """
  updatedCount: Int

  """
  An array of write errors if any were generated
  """
  writeErrors: [WriteError]
}

"""
A Reaction product variant or option
"""
type ProductVariant {
  """
  Variant ID
  """
  _id: ID!

  """
  The attribute label describes the category of variant, for example, `Color` or `Size`.
  In most cases this will be the same for all variants at the same level.
  """
  attributeLabel: String

  """
  The product variant barcode value, if it has one
  """
  barcode: String

  """
  Compare at price of the variant
  """
  compareAtPrice: Float @deprecated(reason: "Use `pricing`")

  """
  The date and time at which this variant was created
  """
  createdAt: DateTime

  """
  The height of the product variant, if it has physical dimensions
  """
  height: Float

  """
  The position of this variant among other variants at the same level of the product-variant-option hierarchy
  """
  index: Int

  """
  True if this variant was deleted. Deleted variants are not published to the catalog.
  """
  isDeleted: Boolean!

  """
  Whether this variant is taxable
  """
  isTaxable: Boolean

  """
  True if this variant is visible. Hidden variants are not published to the catalog.
  """
  isVisible: Boolean!

  """
  The length of the product, if it has physical dimensions
  """
  length: Float

  """
  All media for a variant
  """
  media: [ImageInfo]

  """
  Arbitrary additional metadata about this product
  """
  metafields: [Metafield]!

  """
  The minimum quantity that must be added to a cart
  """
  minOrderQuantity: Int

  """
  A short title to use for product detail select lists
  """
  optionTitle: String

  """
  Child variants, if any
  """
  options(
    """
    Include archived variants
    """
    shouldIncludeArchived: Boolean = false

    """
    Include hidden variants
    """
    shouldIncludeHidden: Boolean = true
  ): [ProductVariant]!

  """
  The country of origin
  """
  originCountry: String

  """
  Price of the variant
  """
  price: Float @deprecated(reason: "Use `pricing`")

  """
  Pricing information
  """
  pricing: ProductPricingInfo!

  """
  The shop to which this product variant belongs
  """
  shop: Shop!

  """
  SKU of variant
  """
  sku: String

  """
  Tax code
  """
  taxCode: String

  """
  Tax description
  """
  taxDescription: String

  """
  The full variant title for use on cart, checkout, and order summaries and on invoices.
  This fully describes the configured variant. For example, if this is an option with
  `optionTitle` "Large", its parent variant has `optionTitle` `Red`, and the product
  `title` is "Fancy T-Shirt", then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  """
  title: String

  """
  The date and time at which this product was last updated
  """
  updatedAt: DateTime

  """
  The weight of the product on Earth, if it has physical dimensions
  """
  weight: Float

  """
  The width of the product, if it has physical dimensions
  """
  width: Float
}

"""
Mutation input for a product variant or option
"""
input ProductVariantInput {
  """
  Any string to use as the internal ID for a new variant. Do not prefix or base64 encode this ID.
  This field is allowed only when creating a variant. If you include an ID for an update, you
  will get an error. The string must also be different from any existing product, variant, or
  option internal ID or you will get a duplicate ID error. If you do not include this when creating
  a variant, a random unique string is generated for you.
  """
  _id: String

  """
  The attribute label describes the category of variant, for example, `Color` or `Size`.
  In most cases this will be the same for all variants at the same level.
  """
  attributeLabel: String

  """
  The product variant barcode value, if it has one
  """
  barcode: String

  """
  Variant compareAtPrice. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices.
  """
  compareAtPrice: Float

  """
  The height of the product variant, if it has physical dimensions
  """
  height: Float

  """
  The position of this variant among other variants at the same level of the product-variant-option hierarchy
  """
  index: Int

  """
  True if this variant was deleted. Deleted variants are not published to the catalog.
  """
  isDeleted: Boolean

  """
  Whether this variant is taxable
  """
  isTaxable: Boolean

  """
  True if this variant is visible. Hidden variants are not published to the catalog.
  """
  isVisible: Boolean

  """
  The length of the product, if it has physical dimensions
  """
  length: Float

  """
  Arbitrary additional metadata about this product
  """
  metafields: [MetafieldInput]

  """
  The minimum quantity that must be added to a cart
  """
  minOrderQuantity: Int

  """
  A short title to use for product detail select lists
  """
  optionTitle: String

  """
  The country of origin
  """
  originCountry: String

  """
  Variant price. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices.
  """
  price: Float

  """
  SKU of variant
  """
  sku: String

  """
  Tax code
  """
  taxCode: String

  """
  Tax description
  """
  taxDescription: String

  """
  The full variant title for use on cart, checkout, and order summaries and on invoices.
  This fully describes the configured variant. For example, if this is an option with
  `optionTitle` `Large`, its parent variant has `optionTitle` `Red`, and the product
  `title` is `Fancy T-Shirt`, then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  """
  title: String

  """
  The weight of the product on Earth, if it has physical dimensions
  """
  weight: Float

  """
  The width of the product, if it has physical dimensions
  """
  width: Float
}

"""
Mutation input for a product variant or option
"""
input ProductVariantPricesInput {
  """
  Variant compareAtPrice
  """
  compareAtPrice: Float

  """
  Variant price
  """
  price: Float
}

"""
"""
type Profile {
  """
  """
  addressBook: [Address]
}

"""
Input for the `publishNavigationChanges` mutation
"""
input PublishNavigationChangesInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the navigation tree
  """
  id: ID!

  """
  Shop ID of the navigation tree
  """
  shopId: ID!
}

"""
Response payload for the `publishNavigationChanges` mutation
"""
type PublishNavigationChangesPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The navigation tree with updated items
  """
  navigationTree: NavigationTree
}

"""
Queries return all requested data, without any side effects
"""
type Query {
  """
  Returns the account with the provided ID
  """
  account(
    """
    The account ID
    """
    id: ID!
  ): Account

  """
  Find a cart for a given account ID.
  """
  accountCartByAccountId(
    """
    Account that owns the cart
    """
    accountId: ID!

    """
    Shop that owns the cart
    """
    shopId: ID!
  ): Cart

  """
  Returns accounts optionally filtered by account groups
  """
  accounts(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return only accounts in any of these groups
    """
    groupIds: [ID]

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return accounts that aren't in any groups
    """
    notInAnyGroups: Boolean

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: AccountSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): AccountConnection!

  """
  Get a list of errors and suggested properly formatted addresses for an address. If no address
  validation service is active for the shop, this will return as if the address is valid even
  though no check actually occurred.
  """
  addressValidation(
    """
    Address to validate
    """
    address: AddressInput!

    """
    Shop to use for determining what validation service to use
    """
    shopId: ID!
  ): AddressValidationResults!

  """
  Returns a list of defined address validation rules for a shop
  """
  addressValidationRules(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    An optional list of service names, to get only rules that specify one of these services
    """
    serviceNames: [String]

    """
    ID of the shop for which to get defined address validation rules
    """
    shopId: ID!

    """
    By default, rules are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: AddressValidationRuleSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): AddressValidationRuleConnection!

  """
  Get a full list of all registered address validation services
  """
  addressValidationServices: [AddressValidationService]!

  """
  Finds a cart by the cart ID and anonymous cart token.
  """
  anonymousCartByCartId(
    """
    The cart ID. Must be an anonymous cart (that is, one with no linked account).
    """
    cartId: ID!

    """
    A valid anonymous cart access cartToken for this cart. This is returned when you create
    an anonymous cart and should be stored securely in storefront client storage.
    """
    cartToken: String!
  ): Cart

  """
  Get a list of all payment methods available during a checkout. This may filter by auth,
  active/inactive, IP/region, shop, etc. To get the full list, use the `paymentMethods`
  query with proper authorization.
  """
  availablePaymentMethods(
    """
    ID of the shop for which the order will be placed
    """
    shopId: ID!
  ): [PaymentMethod]!

  """
  Gets product from catalog
  """
  catalogItemProduct(
    """
    ID of the shop that owns the catalog product. Not required but highly recommended if you
    have multiple shops and `slugOrId` is a slug because slugs are unique only within a shop.
    """
    shopId: ID

    """
    Provide either a product ID or slug
    """
    slugOrId: String
  ): CatalogItemProduct

  """
  Gets items from a shop catalog
  """
  catalogItems(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Additional filters to apply
    """
    booleanFilters: [CatalogBooleanFilter]

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Optional text search query
    """
    searchQuery: String

    """
    Provide a list of shop IDs from which you want to get catalog items
    """
    shopIds: [ID]!

    """
    By default, items are sorted by when they were last updated, most recently updated first. Set this to sort by one of the other allowed fields
    """
    sortBy: CatalogItemSortByField = updatedAt

    """
    Provide a Currency code if sortBy is minPrice
    """
    sortByPriceCurrencyCode: String

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc

    """
    Optionally provide a list of tag IDs to further filter the item list
    """
    tagIds: [ID]
  ): CatalogItemConnection

  """
  Returns customer accounts
  """
  customers(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: AccountSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): AccountConnection!

  """
  Gets discount codes
  """
  discountCodes(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Filters to apply to a discount codes query
    """
    filters: DiscountCodeFilterInput

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Provide a shop ID from which you want to get discount codes
    """
    shopId: ID!
  ): DiscountCodeConnection

  """
  Get e-mail jobs for a given set of shops
  """
  emailJobs(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    The shop IDs to get e-mail jobs for
    """
    shopIds: [ID]!
  ): EmailJobConnection!

  """
  Retrieves a list of email templates
  """
  emailTemplates(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    The shopId to which email templates belong to
    """
    shopId: ID!
  ): TemplateConnection

  """
  Get a flat rate fulfillment method
  """
  flatRateFulfillmentMethod(
    """
    Fulfillment method id
    """
    methodId: ID!

    """
    Shop ID
    """
    shopId: ID!
  ): FlatRateFulfillmentMethod!

  """
  Get a flat rate fulfillment methods
  """
  flatRateFulfillmentMethods(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Shop ID
    """
    shopId: ID!
  ): FlatRateFulfillmentMethodConnection!

  """
  Get a single flat rate fulfillment method restriction.
  """
  getFlatRateFulfillmentRestriction(
    """
    The restriction ID
    """
    restrictionId: ID!

    """
    Shop that owns the restriction
    """
    shopId: ID!
  ): FlatRateFulfillmentRestriction

  """
  Get the full list of flat rate fulfillment method restrictions.
  """
  getFlatRateFulfillmentRestrictions(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Shop to get restrictions for
    """
    shopId: ID!

    """
    By default, restrictions are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: FlatRateFulfillmentRestrictionSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): FlatRateFulfillmentRestrictionConnection!
  getUser: User

  """
  Returns app settings that are not shop specific. Plugins extend the GlobalSettings type to support
  whatever settings they need.
  """
  globalSettings: GlobalSettings!

  """
  Returns a single group by ID.
  """
  group(
    """
    The group ID
    """
    id: ID!
  ): Group

  """
  Returns a list of groups for the shop with ID `shopId`, as a Relay-compatible connection.
  """
  groups(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Return groups for this shop
    """
    shopId: ID!

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: GroupSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): GroupConnection

  """
  Returns all pending staff member invitations
  """
  invitations(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    The shop IDs to get invitations for
    """
    shopIds: [ID]

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: AccountSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): InvitationConnection!

  """
  Returns the navigation items for a shop
  """
  navigationItemsByShopId(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    The ID of the shop to load navigation items for
    """
    shopId: ID!

    """
    By default, items are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: NavigationItemSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): NavigationItemConnection

  """
  Returns a navigation tree by its ID in the specified language
  """
  navigationTreeById(
    """
    The ID of the navigation tee
    """
    id: ID!

    """
    Navigation language
    """
    language: String!

    """
    The ID of the shop to load navigation tree for
    """
    shopId: ID!

    """
    Set to true if you want to include secondary navigation items along with the primary items
    """
    shouldIncludeSecondary: Boolean = false
  ): NavigationTree

  """
  Get an order by its ID
  """
  orderById(
    """
    The order ID
    """
    id: ID!

    """
    The shop that owns the order
    """
    shopId: ID!

    """
    A valid anonymous access token for this order. Required if the order is not linked with an account.
    """
    token: String
  ): Order

  """
  Get an order by its reference ID (the ID shown to customers)
  """
  orderByReferenceId(
    """
    The order reference ID (the ID shown to customers)
    """
    id: ID!

    """
    The shop that owns the order
    """
    shopId: ID!

    """
    A valid anonymous access token for this order. Required if the order is not linked with an account.
    """
    token: String
  ): Order

  """
  Get all orders for a single account, optionally limited to certain shop IDs and certain orderStatus
  """
  orders(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Filters to apply to a list of orders
    """
    filters: OrderFilterInput

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Provide a list of shop IDs from which you want to get orders from
    """
    shopIds: [ID]

    """
    By default, orders are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: OrdersSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): OrderConnection!

  """
  Get all orders for a single account, optionally limited to certain shop IDs and certain orderStatus
  """
  ordersByAccountId(
    """
    Limit to orders placed by this account
    """
    accountId: ID!

    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Limit to orders with one of these statuses
    """
    orderStatus: [String]

    """
    Limit to orders owned by one of these shops
    """
    shopIds: [ID]!

    """
    By default, orders are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: OrdersByAccountIdSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): OrdersByAccountIdConnection!

  """
  Get a full list of all payment methods
  """
  paymentMethods(
    """
    The shop to get payment methods for
    """
    shopId: ID!
  ): [PaymentMethod]!

  """
  A test query
  """
  ping: String!

  """
  Returns the primary shop for the domain
  """
  primaryShop: Shop

  """
  Returns the ID of the primary shop for the domain
  """
  primaryShopId: ID

  """
  Query for a single Product
  """
  product(
    """
    Product ID
    """
    productId: ID!

    """
    Shop ID
    """
    shopId: ID!
  ): Product

  """
  Query for a list of Products
  """
  products(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Filter by created timestamp
    """
    createdAt: ProductDateOperators

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Filter by archived
    """
    isArchived: Boolean

    """
    Flag to set metafields search method. Default value false, performs a fuzzy search. Explicitly set it to true to perform exact match.
    """
    isExactMatch: Boolean = false

    """
    Filter by visibility
    """
    isVisible: Boolean

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Filter by metafield key using `regex` match. To get specific searches send the argument as a regex pattern
    """
    metafieldKey: String

    """
    Filter by metafield value using `regex` match. To get specific searches send the argument as a regex pattern
    """
    metafieldValue: String

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Filter by price range maximum value
    """
    priceMax: Float

    """
    Filter by price range minimum value
    """
    priceMin: Float

    """
    List of product IDs to filter by
    """
    productIds: [ID]

    """
    Regex metch query string
    """
    query: String

    """
    List of shop IDs to filter by
    """
    shopIds: [ID]!

    """
    By default, products are sorted by createdAt. Set this to sort by one of the other allowed fields
    """
    sortBy: ProductSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc

    """
    List of tag ids to filter by
    """
    tagIds: [ID]

    """
    Filter by updated at timestamp
    """
    updatedAt: ProductDateOperators
  ): ProductConnection

  """
  Returns a list of product in a tag
  """
  productsByTagId(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Regex match query string, for product title
    """
    query: String

    """
    Shop that owns the tag
    """
    shopId: ID!

    """
    The tag ID
    """
    tagId: ID!
  ): TagProductConnection!

  """
  Get refunds applied to an order by order ID
  """
  refunds(
    """
    The order ID
    """
    orderId: ID!

    """
    The shop that owns the order
    """
    shopId: ID!

    """
    A valid anonymous access token for this order. Required if the order is not linked with an account.
    """
    token: String
  ): [Refund]

  """
  Get refunds applied to a specific payment by payment ID
  """
  refundsByPaymentId(
    """
    The order ID
    """
    orderId: ID!

    """
    The ID of one of the payments made for this order
    """
    paymentId: ID!

    """
    The shop that owns the order
    """
    shopId: ID!

    """
    A valid anonymous access token for this order. Required if the order is not linked with an account.
    """
    token: String
  ): [Refund]

  """
  Returns a paged list of all roles associated with a shop
  """
  roles(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Return valid roles for this shop
    """
    shopId: ID!

    """
    By default, roles are sorted alphabetically by name. Set this to sort by one of the other allowed fields
    """
    sortBy: RoleSortByField = name

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): RoleConnection

  """
  Returns a shop by ID
  """
  shop(
    """
    The shop ID
    """
    id: ID!
  ): Shop

  """
  Returns a shop by slug
  """
  shopBySlug(
    """
    The shop slug
    """
    slug: String!
  ): Shop

  """
  Returns app settings for a specific shop. Plugins extend the ShopSettings type to support
  whatever settings they need.
  """
  shopSettings(
    """
    The shop to get app settings for
    """
    shopId: ID!
  ): ShopSettings!

  """
  """
  shops(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Shop IDs to filter by
    """
    shopIds: [ID]

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: GroupSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): ShopConnection

  """
  Get the SimpleInventory info for a product configuration. Returns `null` if `updateSimpleInventory`
  has never been called for this product configuration.
  """
  simpleInventory(
    """
    The product configuration for which you want inventory info
    """
    productConfiguration: ProductConfigurationInput!

    """
    ID of the shop that owns the product
    """
    shopId: ID!
  ): SimpleInventoryInfo

  """
  Returns Sitemap object for a shop based on the handle param
  """
  sitemap(
    """
    The sitemap handle
    """
    handle: String!

    """
    Shop URL
    """
    shopUrl: String!
  ): Sitemap

  """
  Get a single surcharge definition by its ID
  """
  surchargeById(
    """
    ID of shop that owns the surcharge definition
    """
    shopId: ID!

    """
    The surcharge ID
    """
    surchargeId: ID!
  ): Surcharge

  """
  Get the full list of surcharges.
  """
  surcharges(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    ID of shop to get surcharges for
    """
    shopId: ID!

    """
    By default, surcharges are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    """
    sortBy: SurchargeSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = desc
  ): SurchargeConnection!

  """
  SystemInformation object
  """
  systemInformation(
    """
    Shop ID to use for shop-specific system information
    """
    shopId: ID!
  ): SystemInformation!

  """
  Returns a tag from a provided tag ID or slug. Tags with isVisible set to false are excluded by default.
  """
  tag(
    """
    The shop to which this tag belongs
    """
    shopId: ID!

    """
    Set to true if you want to include tags that have isVisible set to false
    """
    shouldIncludeInvisible: Boolean = false

    """
    Slug or ID of Tag
    """
    slugOrId: String!
  ): Tag

  """
  Returns a paged list of tags for a shop. You must include a shopId when querying.
  """
  tags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Filter by created timestamp
    """
    createdAt: TagDateOperators

    """
    Tags to exclude from results
    """
    excludedTagIds: [ID]

    """
    If provided, this query will do a regex search using the provided filter data, and return only tags that match
    """
    filter: String

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    If set, the query will return only top-level tags or only non-top-level tags. By default, both types of tags are returned.
    """
    isTopLevel: Boolean

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Only tags associated with this shop will be returned
    """
    shopId: ID!

    """
    Set to true if you want soft deleted tags to be included in the response
    """
    shouldIncludeDeleted: Boolean = false

    """
    Set to true if you want to include tags that have isVisible set to false
    """
    shouldIncludeInvisible: Boolean = false

    """
    By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = position

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc

    """
    Filter by updated at timestamp
    """
    updatedAt: TagDateOperators
  ): TagConnection

  """
  List all tax codes supported by the current active tax service for the shop
  """
  taxCodes(
    """
    The shop to use for getting the list of active tax services
    """
    shopId: ID!
  ): [TaxCode]!

  """
  Gets tax rates
  """
  taxRates(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Provide a shp ID from which you want to get tax rates
    """
    shopId: ID!
  ): TaxRateConnection

  """
  Get a full list of all tax services for the shop
  """
  taxServices(
    """
    The shop to use for getting the list of all tax services
    """
    shopId: ID!
  ): [TaxService]!
  twoFactorSecret: TwoFactorSecretKey

  """
  Gets an array of all vendors
  """
  vendors(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Optionally provide a list of shop IDs from which you want to get the vendors
    """
    shopIds: [ID]

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc

    """
    Optionally provide a list of tag IDs to further filter the vendors
    """
    tagIds: [ID]
  ): VendorConnection

  """
  Returns the account for the authenticated user
  """
  viewer: Account
}

"""
A numeric rate, with its corresponding percent values
"""
type Rate {
  """
  The rate
  """
  amount: Float!

  """
  The percent as a preformatted string with percent symbol included
  """
  displayPercent: String!

  """
  The percent (rate x 100)
  """
  percent: Float!
}

"""
Input for the `recalculateReservedSimpleInventory` mutation
"""
input RecalculateReservedSimpleInventoryInput {
  """
  The product and chosen options this info applies to
  """
  productConfiguration: ProductConfigurationInput!

  """
  Shop that owns the product
  """
  shopId: ID!
}

"""
Response payload for the `updateSimpleInventory` mutation
"""
type RecalculateReservedSimpleInventoryPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated inventory info
  """
  inventoryInfo: SimpleInventoryInfo!
}

"""
Input for the `reconcileCarts` mutation call
"""
input ReconcileCartsInput {
  """
  An anonymous cart ID
  """
  anonymousCartId: ID!

  """
  An anonymous cart token
  """
  cartToken: String!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  If both an anonymous cart and a cart for the authenticated account are found, how do we combine them?
  Default mode is `merge`, where all anonymous items are moved into the account cart along with existing
  account cart items, and quantities are combined.
  """
  mode: CartReconciliationMode

  """
  The ID of the shop that owns both carts
  """
  shopId: ID!
}

"""
The payload returned from the `reconcileCarts` mutation call
"""
type ReconcileCartsPayload {
  """
  The account cart, potentially modified
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
A refund of a payment on an order
"""
type Refund implements Node {
  """
  The refund ID
  """
  _id: ID!

  """
  The amount of the refund
  """
  amount: Money!

  """
  The date and time at which the refund was created
  """
  createdAt: DateTime!

  """
  The display name of the payment refunded to
  """
  paymentDisplayName: String!

  """
  The ID of the payment this refund is applied to
  """
  paymentId: ID!

  """
  The reason for the refund
  """
  reason: String
}

"""
Describes which address should be removed from which account
"""
input RemoveAccountAddressBookEntryInput {
  """
  The account ID
  """
  accountId: ID!

  """
  The address ID
  """
  addressId: ID!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
The response from the `removeAccountAddressBookEntry` mutation
"""
type RemoveAccountAddressBookEntryPayload {
  """
  The removed address
  """
  address: Address

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Defines which email address should be removed from which account
"""
input RemoveAccountEmailRecordInput {
  """
  The account ID, which defaults to the viewer account
  """
  accountId: ID

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address to remove
  """
  email: Email!
}

"""
The response from the `removeAccountEmailRecord` mutation
"""
type RemoveAccountEmailRecordPayload {
  """
  The account, with updated `emailRecords`
  """
  account: Account

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Defines a group and account that should be unlinked
"""
input RemoveAccountFromGroupInput {
  """
  The account ID
  """
  accountId: ID!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group ID
  """
  groupId: ID!
}

"""
The response from the `removeAccountFromGroup` mutation
"""
type RemoveAccountFromGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The removed group
  """
  group: Group!
}

"""
The details for removing a group
"""
input RemoveAccountGroupInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group ID
  """
  groupId: ID!

  """
  The ID of the shop this group belongs to
  """
  shopId: ID
}

"""
The response from the `removeGroup` mutation
"""
type RemoveAccountGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The removed group
  """
  group: Group
}

"""
Input for the `removeCartItems` mutation
"""
input RemoveCartItemsInput {
  """
  The cart ID
  """
  cartId: ID!

  """
  Array of items to remove from the cart.
  """
  cartItemIds: [ID]!

  """
  If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
The payload returned from the `removeCartItems` mutation call
"""
type RemoveCartItemsPayload {
  """
  The modified cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for an `RemoveDiscountCodeFromCartInput`
"""
input RemoveDiscountCodeFromCartInput {
  """
  Cart to add discount to
  """
  cartId: ID!

  """
  ID of the discount you want to remove from the cart
  """
  discountId: ID!

  """
  Shop cart belongs to
  """
  shopId: ID!

  """
  Cart token, if anonymous
  """
  token: String
}

"""
Response from the `removeDiscountCodeFromCart` mutation
"""
type RemoveDiscountCodeFromCartPayload {
  """
  The updated cart with discount code removed
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for `removeTag` mutation
"""
input RemoveTagInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of tag to delete
  """
  id: ID!

  """
  The shop that owns the tag
  """
  shopId: ID!
}

"""
Response payload for `removeTag` mutation
"""
type RemoveTagPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The deleted tag
  """
  tag: Tag!
}

"""
Restriction type
"""
enum RestrictionTypeEnum {
  """
  Allow
  """
  allow

  """
  Deny
  """
  deny
}

"""
Input for `retryFailedEmail` mutation
"""
input RetryFailedEmailInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of Email Job to retry
  """
  jobId: ID!

  """
  Shop ID of Email Job
  """
  shopId: ID!
}

"""
Response payload for `retryFailedEmail` mutation
"""
type RetryFailedEmailPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Email retry status
  """
  emailSent: Boolean!
}

"""
Valid payment risk levels
"""
enum RiskLevel {
  """
  An elevated risk level for a payment
  """
  elevated

  """
  The highest risk level for a payment
  """
  highest

  """
  A normal risk level for a payment
  """
  normal
}

"""
Represents a named role
"""
type Role implements Node {
  """
  The role ID
  """
  _id: ID!

  """
  A unique name for the role
  """
  name: String!
}

"""
Wraps a list of `Roles`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type RoleConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [RoleEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Role]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `Role` object
"""
type RoleEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The role
  """
  node: Role
}

"""
The fields by which you are allowed to sort any query that returns an `RoleConnection`
"""
enum RoleSortByField {
  """
  Role ID
  """
  _id

  """
  Role name
  """
  name
}

"""
Input needed to select a fulfillment option for a single fulfillment group on a cart
"""
input SelectFulfillmentOptionForGroupInput {
  """
  The cart to select this option for
  """
  cartId: ID!

  """
  The token for the cart, required if it is an anonymous cart
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group to select this option for
  """
  fulfillmentGroupId: ID!

  """
  The fulfillment method ID from the option the shopper selected
  """
  fulfillmentMethodId: ID!
}

"""
The response from the `selectFulfillmentOptionForGroup` mutation
"""
type SelectFulfillmentOptionForGroupPayload {
  """
  The updated Cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Describes which email should be sent a password reset link
"""
input SendResetAccountPasswordEmailInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address of the account to send reset email to
  """
  email: String!
}

"""
The response from the `sendResetAccountPasswordEmail` mutation
"""
type SendResetAccountPasswordEmailPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The email address of the account to send reset email to
  """
  email: String!
}

"""
Defines which email address should be set as the default for which account
"""
input SetAccountDefaultEmailInput {
  """
  The account ID, which defaults to the viewer account
  """
  accountId: ID

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address to set as default
  """
  email: Email!
}

"""
The response from the `setAccountDefaultEmail` mutation
"""
type SetAccountDefaultEmailPayload {
  """
  The account, with updated `emailRecords`
  """
  account: Account

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the `setEmailOnAnonymousCart` mutation call
"""
input SetEmailOnAnonymousCartInput {
  """
  An anonymous cart ID
  """
  cartId: ID!

  """
  Provide the `cartToken` that was returned in the `CreateCartPayload`
  """
  cartToken: String!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The email address to associate with this cart. This address is used for order communication and
  other fulfillment purposes.
  """
  email: String!
}

"""
The payload returned from the `setEmailOnAnonymousCart` mutation call
"""
type SetEmailOnAnonymousCartPayload {
  """
  The modified cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input needed when setting the shipping address on a cart
"""
input SetShippingAddressOnCartInput {
  """
  The shipping address
  """
  address: AddressInput!

  """
  If set, this will be saved as the Address._id. Otherwise an ID will be generated.
  """
  addressId: String

  """
  The cart to set shipping address on
  """
  cartId: ID!

  """
  The token for the cart, required if it is an anonymous cart
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
The response from the `setShippingAddressOnCart` mutation
"""
type SetShippingAddressOnCartPayload {
  """
  The updated Cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for `setTagHeroMedia` mutation
"""
input SetTagHeroMediaInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  File record document
  """
  fileRecord: JSONObject

  """
  ID of tag to add the hero image record to
  """
  id: ID!

  """
  The shop that owns the tag
  """
  shopId: ID!
}

"""
Response payload for `setTagHeroMedia` mutation
"""
type SetTagHeroMediaPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Tag the hero image was added to
  """
  tag: Tag!
}

"""
Extra data for an order fulfillment group with type `shipping`
"""
type ShippingOrderFulfillmentGroupData {
  """
  The address to ship to
  """
  shippingAddress: Address!
}

"""
A shipping parcel
"""
type ShippingParcel {
  """
  Containers
  """
  containers: String

  """
  Distance unit
  """
  distanceUnit: DistanceUnit

  """
  Height
  """
  height: Float

  """
  Length
  """
  length: Float

  """
  Mass unit
  """
  massUnit: MassUnit

  """
  Weight
  """
  weight: Float

  """
  Width
  """
  width: Float
}

"""
Represents a Reaction shop
"""
type Shop implements Node {
  """
  The shop ID
  """
  _id: ID!

  """
  An the shop's default address
  """
  addressBook: [Address]

  """
  Whether to allow user to checkout without creating an account
  """
  allowGuestCheckout: Boolean

  """
  The base unit of length
  """
  baseUOL: String

  """
  The base unit of Measure
  """
  baseUOM: String

  """
  URLs for various shop assets in various sizes
  """
  brandAssets: ShopBrandAssets

  """
  The default shop currency
  """
  currency: Currency!

  """
  The default navigation tree for this shop
  """
  defaultNavigationTree(
    """
    Navigation tree language
    """
    language: String!

    """
    Whether to include secondary navigation items
    """
    shouldIncludeSecondary: Boolean = false
  ): NavigationTree

  """
  The ID of the shop's default navigation tree
  """
  defaultNavigationTreeId: String

  """
  Default parcel size for this shop
  """
  defaultParcelSize: ShopParcelSize

  """
  Shop description
  """
  description: String

  """
  The shop's default email record
  """
  emails: [EmailRecord]

  """
  Returns a list of groups for this shop, as a Relay-compatible connection.
  """
  groups(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    """
    sortBy: GroupSortByField = createdAt

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): GroupConnection

  """
  Shop's keywords
  """
  keywords: String

  """
  Shop default language
  """
  language: String!

  """
  Shop name
  """
  name: String!

  """
  Returns a list of roles for this shop, as a Relay-compatible connection.
  """
  roles(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, roles are sorted alphabetically by name. Set this to sort by one of the other allowed fields
    """
    sortBy: RoleSortByField = name

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): RoleConnection

  """
  Returns URLs for shop logos
  """
  shopLogoUrls: ShopLogoUrls

  """
  Shop's type
  """
  shopType: String

  """
  Shop's slug
  """
  slug: String

  """
  Returns URLs for various storefront routes
  """
  storefrontUrls: StorefrontUrls

  """
  Returns a paged list of tags for this shop
  """
  tags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    If set, the query will return only top-level tags or only non-top-level tags. By default, both types of tags are returned.
    """
    isTopLevel: Boolean

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    Set to true if you want soft deleted tags to be included in the response
    """
    shouldIncludeDeleted: Boolean = false

    """
    By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = position

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  Shop default timezone
  """
  timezone: String

  """
  The shop's units of length
  """
  unitsOfLength: [UnitOfLength]

  """
  The shop's units of measure
  """
  unitsOfMeasure: [UnitOfMeasure]
}

"""
URLs for various shop assets in various sizes
"""
type ShopBrandAssets {
  """
  URLs for the navigation bar brand logo image
  """
  navbarBrandImage: ImageSizes

  """
  Internal navigation bar brand logo image ID
  """
  navbarBrandImageId: String
}

"""
Wraps a list of `Shops`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type ShopConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [ShopEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Shop]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is an `Shop` object
"""
type ShopEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The Shop
  """
  node: Shop
}

"""
Shop logo URLs
"""
type ShopLogoUrls {
  """
  The primary logo URL for this shop. Setting this overrides any uploaded logo.
  """
  primaryShopLogoUrl: String
}

"""
Shop Logo URLs to provide for the updateShop mutation
"""
input ShopLogoUrlsInput {
  """
  The primary logo URL for this shop. Setting this overrides any uploaded logo.
  """
  primaryShopLogoUrl: String
}

"""
Parcel size
"""
type ShopParcelSize {
  """
  Parcel height
  """
  height: Float

  """
  Parcel length
  """
  length: Float

  """
  Parcel weight
  """
  weight: Float

  """
  Parcel width
  """
  width: Float
}

"""
Parcel size input
"""
input ShopParcelSizeInput {
  """
  Parcel height
  """
  height: Float

  """
  Parcel length
  """
  length: Float

  """
  Parcel weight
  """
  weight: Float

  """
  Parcel width
  """
  width: Float
}

"""
App settings for a specific shop. Plugins extend the ShopSettings type to support
whatever settings they need.
"""
type ShopSettings {
  """
  If there is no known inventory for a product configuration, this setting determines
  whether that product configuration can be sold and should appear to be available.
  """
  canSellVariantWithoutInventory: Boolean!

  """
  The default value to use for `taxCode` property of a product
  """
  defaultTaxCode: String

  """
  A fake setting necessary until some plugin extends this with a real setting
  """
  doNotUse: String

  """
  The name of the tax service to fall back to if the primary tax service is down.
  This will match the `name` field of one of the services returned by the `taxServices`
  query.
  """
  fallbackTaxServiceName: String

  """
  If `false` no defined shipping rates will be used when fulfillment
  quotes are requested for a cart or order. A quick way to disable the entire
  `reaction-shipping-rates` plugin temporarily.
  """
  isShippingRatesFulfillmentEnabled: Boolean

  """
  The name of the tax service to use for calculating taxes on carts and orders.
  This will match the `name` field of one of the services returned by the `taxServices`
  query.
  """
  primaryTaxServiceName: String

  """
  Whether a navigation item added to the navigation tree should be visible only to
  admins by default.
  """
  shouldNavigationTreeItemsBeAdminOnly: Boolean!

  """
  Whether a navigation item added to the navigation tree should be
  public API/Storefront visible by default.
  """
  shouldNavigationTreeItemsBePubliclyVisible: Boolean!

  """
  Whether a navigation item added to the navigation tree should be a secondary
  navigation item by default.
  """
  shouldNavigationTreeItemsBeSecondaryNavOnly: Boolean!

  """
  This setting controls how often the sitemaps for the shop will be rebuilt
  """
  sitemapRefreshPeriod: String!
}

"""
Updates for app settings that are not shop specific. Plugins extend
this input type to support whatever settings they need. All fields
must be optional.
"""
input ShopSettingsUpdates {
  """
  If there is no known inventory for a product configuration, this setting determines
  whether that product configuration can be sold and should appear to be available.
  """
  canSellVariantWithoutInventory: Boolean

  """
  The default value to use for `taxCode` property of a product
  """
  defaultTaxCode: String

  """
  Do not use this field
  """
  doNotUse: String

  """
  Optionally, set the name of the tax service to fall back to if the primary tax service is down.
  This must match the `name` field of one of the services returned by the `taxServices` query.
  """
  fallbackTaxServiceName: String

  """
  Set to `false` to prevent any defined shipping rates from being used when fulfillment
  quotes are requested for a cart or order. A quick way to disable the entire
  `reaction-shipping-rates` plugin temporarily.
  """
  isShippingRatesFulfillmentEnabled: Boolean

  """
  Set the name of the tax service to use for calculating taxes on carts and orders.
  This will match the `name` field of one of the services returned by the `taxServices`
  query. There will be no taxes charged for any carts or orders if this is not set.
  """
  primaryTaxServiceName: String

  """
  Whether a navigation item added to the navigation tree should be visible only to
  admins by default.
  """
  shouldNavigationTreeItemsBeAdminOnly: Boolean

  """
  Whether a navigation item added to the navigation tree should be
  public API/Storefront visible by default.
  """
  shouldNavigationTreeItemsBePubliclyVisible: Boolean

  """
  Whether a navigation item added to the navigation tree should be a secondary
  navigation item by default.
  """
  shouldNavigationTreeItemsBeSecondaryNavOnly: Boolean

  """
  This setting controls how often the sitemaps for the shop will be rebuilt
  """
  sitemapRefreshPeriod: String
}

"""
Inventory info for a specific product configuration. For inventory managed by the SimpleInventory plugin.
"""
type SimpleInventoryInfo {
  """
  Whether to allow ordering this product configuration when there is insufficient quantity available
  """
  canBackorder: Boolean

  """
  Current quantity of this product configuration in stock
  """
  inventoryInStock: Int

  """
  Current quantity of this product configuration unavailable for ordering. This value is calculated
  by the system based on this product variant being in not-yet-approved orders.
  """
  inventoryReserved: Int

  """
  Whether the SimpleInventory plugin should manage inventory for this product configuration
  """
  isEnabled: Boolean

  """
  The "low quantity" flag will be applied to this product configuration when the available quantity
  is at or below this threshold
  """
  lowInventoryWarningThreshold: Int

  """
  The product and chosen options this info applies to
  """
  productConfiguration: ProductConfiguration!
}

"""
Generated sitemap XML for a single shop
"""
type Sitemap {
  """
  Date created
  """
  createdAt: Date!

  """
  The sitemap handle
  """
  handle: String!

  """
  The shop ID
  """
  shopId: String!

  """
  The Sitemap XML content
  """
  xml: String!
}

"""
Holds metadata specific to a specific social network service
"""
type SocialMetadata {
  """
  Default share message to use when sharing this product on this social network
  """
  message: String

  """
  Which social network is this metadata for
  """
  service: SocialNetwork
}

"""
The list of currently supported social network identifiers
"""
enum SocialNetwork {
  """
  Facebook
  """
  facebook

  """
  Google+
  """
  googleplus

  """
  Pinterest
  """
  pinterest

  """
  Twitter
  """
  twitter
}

"""
The order in which the connection results should be sorted, based on the sortBy field.
"""
enum SortOrder {
  """
  ascending
  """
  asc

  """
  descending
  """
  desc
}

"""
Input for the splitOrderItem mutation
"""
input SplitOrderItemInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of the item order you want to split
  """
  itemId: ID!

  """
  The quantity that will be transferred to a new order item on the same fulfillment group.
  """
  newItemQuantity: Int!

  """
  ID of the order that has the item you want to split
  """
  orderId: ID!
}

"""
Response payload for the splitOrderItem mutation
"""
type SplitOrderItemPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The ID of the new order item that was created
  """
  newItemId: ID!

  """
  The updated order
  """
  order: Order!
}

"""
Storefront route URLs
"""
type StorefrontUrls {
  """
  Storefront Account Profile URL (can include `:accountId` in string)
  """
  storefrontAccountProfileUrl: String

  """
  Storefront Home URL
  """
  storefrontHomeUrl: String

  """
  Storefront login URL
  """
  storefrontLoginUrl: String

  """
  Storefront single order URL (can include `:orderReferenceId` and `:orderToken` in string)
  """
  storefrontOrderUrl: String

  """
  Storefront orders URL (can include `:accountId` in string)
  """
  storefrontOrdersUrl: String
}

"""
Storefront route URLs to provide for the updateShop mutation
"""
input StorefrontUrlsInput {
  """
  Storefront Account Profile URL (can include `:accountId` in string)
  """
  storefrontAccountProfileUrl: String

  """
  Storefront Home URL
  """
  storefrontHomeUrl: String

  """
  Storefront login URL
  """
  storefrontLoginUrl: String

  """
  Storefront single order URL (can include `:orderReferenceId` and `:orderToken` in string)
  """
  storefrontOrderUrl: String

  """
  Storefront orders URL (can include `:accountId` in string)
  """
  storefrontOrdersUrl: String
}

"""
Data for a Stripe payment intent
"""
type StripePaymentIntentData {
  """
  The Stripe charge ID
  """
  chargeId: String!

  """
  The Stripe customer ID, if a Stripe customer exists for this charge
  """
  customerId: String
}

"""
Subscriptions allow you to request to get updated data whenever it changes
"""
type Subscription {
  """
  A test subscription that returns an incremented number every 1 second for 10 seconds
  """
  tick: Int!
}

"""
An address suggestion returned from an address validation service
"""
type SuggestedAddress {
  """
  The street address / first line
  """
  address1: String!

  """
  Optional second line
  """
  address2: String

  """
  City
  """
  city: String!

  """
  Country
  """
  country: String!

  """
  Postal code
  """
  postal: String!

  """
  Region. For example, a U.S. state
  """
  region: String!
}

"""
Defines a surcharge for surchargeById and surcharges query.
"""
type Surcharge implements Node {
  """
  The surcharge ID.
  """
  _id: ID!

  """
  Amount.
  """
  amount: Money!

  """
  Attribute restrictions.
  """
  attributes: [SurchargeAttributeRestrictions]

  """
  The date and time at which this surcharge was created
  """
  createdAt: DateTime!

  """
  Destination restrictions.
  """
  destination: SurchargeDestinationRestrictions

  """
  Message translated into provided / default language.
  """
  message(
    """
    The language in which you want the message. If no translation is available for this language,
    it will be in the default language of the related shop.
    """
    language: String!
  ): String!

  """
  Messages provided with content and all languages
  """
  messagesByLanguage: [SurchargeMessagesByLanguage]

  """
  Method IDs to apply this surcharge to.
  """
  methodIds: [ID]

  """
  The shop ID
  """
  shopId: ID!

  """
  The type of this surcharge. Allowed types `surcharge`.
  """
  type: SurchargeTypeEnum!

  """
  The date and time at which this surcharge was last updated
  """
  updatedAt: DateTime
}

"""
Attribute Restrictions attached to a Surcharge
"""
type SurchargeAttributeRestrictions {
  """
  The operator to use for value comparison
  """
  operator: String

  """
  The property to check
  """
  property: String

  """
  The type of this property
  """
  propertyType: SurchargePropertyType

  """
  The value to check for
  """
  value: String
}

"""
Input to add a surcharge attribute restriction
"""
input SurchargeAttributeRestrictionsInput {
  """
  The operator to use for value comparison
  """
  operator: String

  """
  The property to check
  """
  property: String

  """
  The type of this property
  """
  propertyType: SurchargePropertyType

  """
  The value to check for
  """
  value: String
}

"""
Wraps a list of `Surcharge`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type SurchargeConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [SurchargeEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Surcharge]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  Total count for all pages
  """
  totalCount: Int!
}

"""
Destination restrictions attached to a surcharge. If multiple of `country`,
`region`, and `postal` are set, there is an AND relationship.
"""
type SurchargeDestinationRestrictions {
  """
  Restrict for any of these destination countries
  """
  country: [String]

  """
  Restrict for any of these destination postal codes
  """
  postal: [String]

  """
  Restrict for any of these destination regions
  """
  region: [String]
}

"""
Input to add a surcharge destination restriction
"""
input SurchargeDestinationRestrictionsInput {
  """
  Restrict for any of these destination countries
  """
  country: [String]

  """
  Restrict for any of these destination postal codes
  """
  postal: [String]

  """
  Restrict for any of these destination regions
  """
  region: [String]
}

"""
A connection edge in which each node is a `Surcharge` object
"""
type SurchargeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The surcharge
  """
  node: Surcharge
}

"""
Defines a surcharge.
"""
input SurchargeInput {
  """
  Amount.
  """
  amount: Float!

  """
  Attribute restrictions.
  """
  attributes: [SurchargeAttributeRestrictionsInput]

  """
  Destination restrictions.
  """
  destination: SurchargeDestinationRestrictionsInput

  """
  Messages by language.
  """
  messagesByLanguage: [MessagesByLanguageInput]!

  """
  Method IDs to apply this surcharge to.
  """
  methodIds: [ID]

  """
  The type of this surcharge. Allowed types are `surcharge`.
  """
  type: SurchargeTypeEnum!
}

"""
Object that includes translated content and language of translation
"""
type SurchargeMessagesByLanguage {
  """
  The message for this language
  """
  content: String!

  """
  The language code
  """
  language: String!
}

"""
A list of the possible property types for surcharges
"""
enum SurchargePropertyType {
  """
  Boolean
  """
  bool

  """
  Float
  """
  float

  """
  Integer
  """
  int

  """
  String
  """
  string
}

"""
Allowed values for surcharge `sortBy` parameter
"""
enum SurchargeSortByField {
  """
  The date the surcharge definition was created
  """
  createdAt
}

"""
Allowed values for surcharge type
"""
enum SurchargeTypeEnum {
  """
  Surcharge
  """
  surcharge
}

"""
Represents Reaction System Infomation
"""
type SystemInformation {
  """
  Core api version
  """
  apiVersion: String!

  """
  Mongo version
  """
  mongoVersion: DatabaseInformation!

  """
  Plugins installed with name, version information
  """
  plugins: [Plugin]
}

"""
Represents a single tag
"""
type Tag implements Deletable & Node {
  """
  The tag ID
  """
  _id: ID!

  """
  The date and time at which this tag was created
  """
  createdAt: DateTime!

  """
  A string of the title to be displayed on a Tag Listing Page
  """
  displayTitle: String

  """
  A list of the IDs of top products in this tag
  """
  featuredProductIds: [ID]

  """
  A string containing the hero image url for a Tag Listing Page
  """
  heroMediaUrl: String

  """
  If `true`, this object should be considered deleted. Soft deleted objects are not
  returned in query results unless you explicitly ask for them.
  """
  isDeleted: Boolean!

  """
  If `true`, this tag should be shown at the top level of the tag hierarchy
  """
  isTopLevel: Boolean!

  """
  If `true`, this tag's Tag Listing Page should be visible to the public
  """
  isVisible: Boolean!

  """
  Arbitrary additional metadata about this tag
  """
  metafields: [Metafield]

  """
  The display name for the tag. This is unique within a given shop.
  """
  name: String!

  """
  The tag's position relative to other tags at the same level of the tag hierarchy
  """
  position: Int

  """
  The shop to which this tag belongs
  """
  shop: Shop!

  """
  A unique URL-safe string representing this tag for links
  """
  slug: String

  """
  A list of the IDs of tags that have this tag as their parent in the tag hierarchy, in the user-defined order
  """
  subTagIds: [ID]!

  """
  A paged list of tags that have this tag as their parent in the tag hierarchy. Currently only three levels are supported.
  """
  subTags(
    """
    Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    """
    after: ConnectionCursor

    """
    Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    """
    before: ConnectionCursor

    """
    Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    """
    first: ConnectionLimitInt

    """
    Return at most this many results. This parameter may be used with the `before` parameter.
    """
    last: ConnectionLimitInt

    """
    Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    """
    offset: Int

    """
    By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    """
    sortBy: TagSortByField = position

    """
    Return results sorted in this order
    """
    sortOrder: SortOrder = asc
  ): TagConnection

  """
  The date and time at which this tag was last updated
  """
  updatedAt: DateTime!
}

"""
Wraps a list of `Tags`, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type TagConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [TagEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Tag]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
Operators for filtering on a DateTime field
"""
input TagDateOperators {
  """
  The value must be greater than or equal to the given value
  """
  after: DateTime

  """
  The value must be greater than the given value
  """
  before: DateTime

  """
  The value must be between the given values
  """
  between: ProductDateRange

  """
  The value must be equal to the given value
  """
  eq: DateTime
}

"""
Range operator for DateTime fields
"""
input TagDateRange {
  """
  The end of the date range
  """
  end: DateTime!

  """
  The start of the date range
  """
  start: DateTime!
}

"""
A connection edge in which each node is a `Tag` object
"""
type TagEdge implements NodeEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The tag
  """
  node: Tag
}

"""
A tag product
"""
type TagProduct {
  """
  The product id
  """
  _id: ID!

  """
  The date and time at which this CatalogProduct was created, which is when the related product was first published
  """
  createdAt: DateTime!

  """
  Position of the product
  """
  position: Int

  """
  The title of the product
  """
  title: String
}

"""
Wraps a list of `TagProduct`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type TagProductConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [TagProductEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [TagProduct]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `TagProduct` object
"""
type TagProductEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The tag product
  """
  node: TagProduct
}

"""
The fields by which you are allowed to sort any query that returns a `TagConnection`
"""
enum TagSortByField {
  """
  Tag ID
  """
  _id

  """
  Date and time the tag was created
  """
  createdAt

  """
  Tag name
  """
  name

  """
  Tag position
  """
  position

  """
  Date and time the tag was last updated
  """
  updatedAt
}

"""
A tax code that may be used on a product to indicate proper taxation category
"""
type TaxCode {
  """
  The code
  """
  code: String!

  """
  Short description of what types of products the code is for
  """
  label: String!
}

"""
A single calculated tax for a cart, order group, cart item, or order item
"""
type TaxRate {
  """
  Tax rate ID
  """
  _id: ID!

  """
  An optional country code to limit where this tax is applied, in conjunction with `sourcing` field
  """
  country: String

  """
  An optional postal code to limit where this tax is applied, in conjunction with `sourcing` field
  """
  postal: String

  """
  The tax rate. For example, 0.05 for a 5% sales tax.
  """
  rate: Float!

  """
  An optional region (e.g., state) to limit where this tax is applied, in conjunction with `sourcing` field
  """
  region: String

  """
  The shop to which this TaxRate belongs
  """
  shop: Shop!

  """
  Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  """
  sourcing: TaxSource!

  """
  An optional tax code, to apply this tax rate to only products that have this tax code
  """
  taxCode: String
}

"""
Wraps a list of TaxRate`s, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type TaxRateConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [TaxRateEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [TaxRate]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `TaxRate` object
"""
type TaxRateEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The tax rate
  """
  node: TaxRate
}

"""
A service registered by a tax plugin, that provides tax codes and calculations
"""
type TaxService {
  """
  Human-readable display name
  """
  displayName: String!

  """
  The tax service name. Any valid name that has been registered by a tax plugin.
  """
  name: String!

  """
  Name of the plugin that added the tax service
  """
  pluginName: String!
}

"""
Tax sources
"""
enum TaxSource {
  """
  Tax is applied when the destination matches the tax jurisdiction
  """
  destination

  """
  Tax is applied when the origin matches the tax jurisdiction
  """
  origin
}

"""
A summary of tax-related calculations for a cart or order group
"""
type TaxSummary {
  """
  The time at which taxes were last calculated for the cart or order group
  """
  calculatedAt: DateTime!

  """
  The name of the tax service that last calculated taxes for the cart or order group
  """
  calculatedByTaxServiceName: String

  """
  A reference ID for the external system that calculated the taxes
  """
  referenceId: String

  """
  Total tax calculated by the active tax service
  """
  tax: Money!

  """
  Amount that was deemed subject to any taxes by the active tax service
  """
  taxableAmount: Money!

  """
  Full list of all taxes that were calculated by the active tax service for the cart or order group
  """
  taxes: [CalculatedTax]!
}

"""
Represents a Template
"""
type Template implements Node {
  """
  The shop ID
  """
  _id: ID!

  """
  Email template language
  """
  language: String

  """
  Email template name
  """
  name: String

  """
  The shop that owns the template
  """
  shopId: ID!

  """
  Email template string
  """
  subject: String

  """
  Email template body or html text
  """
  template: String

  """
  Email template title
  """
  title: String
}

"""
Wraps a list of Templates, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type TemplateConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [TemplateEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Template]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a `Template` object
"""
type TemplateEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The email template
  """
  node: Template
}

type Tokens {
  accessToken: String
  refreshToken: String
}

type TwoFactorSecretKey {
  ascii: String
  base32: String
  google_auth_qr: String
  hex: String
  otpauth_url: String
  qr_code_ascii: String
  qr_code_base32: String
  qr_code_hex: String
}

input TwoFactorSecretKeyInput {
  ascii: String
  base32: String
  google_auth_qr: String
  hex: String
  otpauth_url: String
  qr_code_ascii: String
  qr_code_base32: String
  qr_code_hex: String
}

"""
Units of length
"""
type UnitOfLength {
  """
  Whether this unit of length is the default
  """
  default: Boolean

  """
  The name of the unit of length
  """
  label: String

  """
  Unit of length
  """
  uol: String
}

"""
Units of measure
"""
type UnitOfMeasure {
  """
  Whether this unit of measure is the default
  """
  default: Boolean

  """
  The name of the unit of measure
  """
  label: String

  """
  Unit of measure
  """
  uom: String
}

"""
Describes changes that should be applied to one of the addresses for an account
"""
input UpdateAccountAddressBookEntryInput {
  """
  The account ID
  """
  accountId: ID!

  """
  The address ID
  """
  addressId: ID!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  If present, make this address the default address of this type
  """
  type: AddressType

  """
  The address changes to apply
  """
  updates: AddressInput!
}

"""
The response from the `updateAccountAddressBookEntry` mutation
"""
type UpdateAccountAddressBookEntryPayload {
  """
  The updated address
  """
  address: Address

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
The details for updating a group
"""
input UpdateAccountGroupInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The changes to apply to the group
  """
  group: UpdateGroupInput!

  """
  The group ID
  """
  groupId: ID!

  """
  The ID of the shop this group belongs to
  """
  shopId: ID
}

"""
The response from the `updateAccountGroup` mutation
"""
type UpdateAccountGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated group
  """
  group: Group
}

"""
Describes an account update
"""
input UpdateAccountInput {
  """
  The account ID, which defaults to the viewer account
  """
  accountId: ID

  """
  Bio to display on profile
  """
  bio: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The preferred currency code used by this account
  """
  currencyCode: String

  """
  The first name of the person this account represents
  """
  firstName: String

  """
  The preferred language (code) used by this account
  """
  language: String

  """
  The last name of the person this account represents
  """
  lastName: String

  """
  The full name of the person this account represents
  """
  name: String

  """
  Some note about this account
  """
  note: String

  """
  URL of picture to display on profile
  """
  picture: String

  """
  Username
  """
  username: String
}

"""
The response from the `updateAccount` mutation
"""
type UpdateAccountPayload {
  """
  The updated account
  """
  account: Account!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the `updateAddressValidationRule` mutation
"""
input UpdateAddressValidationRuleInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Country codes for which this service is enabled. `null` means all, while an empty array means none.
  """
  countryCodes: [String]

  """
  ID of the rule you want to update
  """
  ruleId: ID!

  """
  The name of one of the installed validation services. Use `addressValidationServices`
  query to get a list, and then use the `name` field value from one of them.
  """
  serviceName: String!

  """
  Shop ID of the rule you want to update. This is not something you can modify.
  """
  shopId: ID!
}

"""
Payload for the `updateAddressValidationRule` mutation
"""
type UpdateAddressValidationRulePayload {
  """
  Updated address validation rule
  """
  addressValidationRule: AddressValidationRule!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
"""
input UpdateAdminUIAccessInput {
  """
  The account IDs to update
  """
  accountIds: [String]!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop IDs to unassign or assign to the accounts
  """
  shopIds: [String]!
}

"""
"""
type UpdateAdminUIAccessPayload {
  """
  The up to date account objects
  """
  accounts: [Account]

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String
}

"""
Input for the `updateCartItem` mutation
"""
input UpdateCartItemInput {
  """
  The cart item ID
  """
  cartItemId: ID!

  """
  New absolute value for specified cart item's quantity. Not an incremental value.
  """
  quantity: Int!
}

"""
Input for the `updateCartItemsQuantity` mutation
"""
input UpdateCartItemsQuantityInput {
  """
  The cart ID
  """
  cartId: ID!

  """
  If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Array of cart item quantities to update.
  """
  items: [UpdateCartItemInput]!
}

"""
The payload returned from the `updateCartItemsQuantity` mutation call
"""
type UpdateCartItemsQuantityPayload {
  """
  The modified cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Describes the input for updating a discount code
"""
input UpdateDiscountCodeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The discount code to update
  """
  discountCode: DiscountCodeInput

  """
  The ID of the discount code to update
  """
  discountCodeId: ID!

  """
  The shop ID of the discount code to update
  """
  shopId: ID!
}

"""
The response from the `updateDiscountCode` mutation
"""
type UpdateDiscountCodePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated discount code
  """
  discountCode: DiscountCode
}

"""
Input for the `updateFlatRateFulfillmentMethod` mutation
"""
input UpdateFlatRateFulfillmentMethodInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The updated method. Pass the whole updated method object without the ID.
  """
  method: FlatRateFulfillmentMethodInput!

  """
  The ID of the flat rate fulfillment method you want to update
  """
  methodId: ID!

  """
  The shop that owns the method
  """
  shopId: ID!
}

"""
Response from the `updateFlatRateFulfillmentMethod` mutation
"""
type UpdateFlatRateFulfillmentMethodPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated fulfillment method
  """
  method: FlatRateFulfillmentMethod!
}

"""
Input for the `updateFlatRateFulfillmentRestriction` mutation
"""
input UpdateFlatRateFulfillmentRestrictionInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The updated flat rate fulfillment method restriction. Pass the whole updated restriction object without the ID.
  """
  restriction: FlatRateFulfillmentRestrictionInput!

  """
  The ID of the flat rate fulfillment method restriction you want to update
  """
  restrictionId: ID!

  """
  The shop that owns the flat rate fulfillment method restriction
  """
  shopId: ID!
}

"""
Response from the `updateFlatRateFulfillmentMethod` mutation
"""
type UpdateFlatRateFulfillmentRestrictionPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated flat rate fulfillment method restriction
  """
  restriction: FlatRateFulfillmentRestriction!
}

"""
A request to update the available fulfillment options for a single fulfillment group
"""
input UpdateFulfillmentOptionsForGroupInput {
  """
  The cart to update fulfillment options for
  """
  cartId: ID!

  """
  The token for the cart, required if it is an anonymous cart
  """
  cartToken: String

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group to update fulfillment options for
  """
  fulfillmentGroupId: ID!
}

"""
The response from the `updateFulfillmentOptionsForGroup` mutation
"""
type UpdateFulfillmentOptionsForGroupPayload {
  """
  The updated Cart
  """
  cart: Cart!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the `updateGlobalSettings` mutation
"""
input UpdateGlobalSettingsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Updated settings values. Only includes settings to be changed.
  """
  settingsUpdates: GlobalSettingsUpdates!
}

"""
Response payload for the `updateGlobalSettings` mutation
"""
type UpdateGlobalSettingsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Updated global settings
  """
  globalSettings: GlobalSettings!
}

"""
Fields to update for an existing account group
"""
input UpdateGroupInput {
  """
  A free text description of this group
  """
  description: String

  """
  A unique name for the group
  """
  name: String

  """
  A list of the account permissions implied by membership in this group
  """
  permissions: [String]

  """
  A unique URL-safe string representing this group
  """
  slug: String
}

"""
"""
input UpdateGroupsForAccountsInput {
  """
  The account IDs
  """
  accountIds: [ID]!

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The group IDs
  """
  groupIds: [ID]!
}

"""
"""
type UpdateGroupsForAccountsPayload {
  """
  The accounts that were modified
  """
  accounts: [Account]!

  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String
}

"""
Input for the updateMediaRecordPriority mutation
"""
input UpdateMediaRecordPriorityInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of MediaRecord to update
  """
  mediaRecordId: ID!

  """
  New priority value
  """
  priority: Int!

  """
  ID of shop that owns this MediaRecord
  """
  shopId: ID!
}

"""
Response payload for the updateMediaRecordPriority mutation
"""
type UpdateMediaRecordPriorityPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated MediaRecord
  """
  mediaRecord: MediaRecord!
}

"""
Input for the `updateNavigationItem` mutation
"""
input UpdateNavigationItemInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the navigation item to update
  """
  id: ID!

  """
  The field updates to apply
  """
  navigationItem: NavigationItemInput!

  """
  The ID of the shop navigation item belongs to
  """
  shopId: ID!
}

"""
Response payload for the `updateNavigationItem` mutation
"""
type UpdateNavigationItemPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated navigation item
  """
  navigationItem: NavigationItem
}

"""
Input for the `updateNavigationTree` mutation
"""
input UpdateNavigationTreeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The ID of the navigation tree to update
  """
  id: ID!

  """
  The field updates to apply
  """
  navigationTree: NavigationTreeInput!

  """
  The ID of the shop navigation item belongs to
  """
  shopId: ID!
}

"""
Response payload for the `updateNavigationTree` mutation
"""
type UpdateNavigationTreePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated navigation tree
  """
  navigationTree: NavigationTree
}

"""
Input for the updateOrderFulfillmentGroup mutation
"""
input UpdateOrderFulfillmentGroupInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of the order fulfillment group to update
  """
  orderFulfillmentGroupId: ID!

  """
  ID of the order to update
  """
  orderId: ID!

  """
  Set the current order fulfillment group status to this
  """
  status: String

  """
  Set this as the current order fulfillment group shipment tracking reference
  """
  tracking: String

  """
  Set this as the current order fulfillment group shipment tracking URL
  """
  trackingUrl: String
}

"""
Response payload for the updateOrderFulfillmentGroup mutation
"""
type UpdateOrderFulfillmentGroupPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Input for the updateOrder mutation
"""
input UpdateOrderInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Set the order email to this
  """
  email: String

  """
  ID of the order to update
  """
  orderId: ID!

  """
  Set the current order status to this
  """
  status: String
}

"""
Response payload for the updateOrder mutation
"""
type UpdateOrderPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated order
  """
  order: Order!
}

"""
Input for the `updateProduct` mutation
"""
input UpdateProductInput {
  """
  Product input
  """
  product: ProductInput!

  """
  ID of product to update
  """
  productId: ID!

  """
  ID of shop that owns the product to update
  """
  shopId: ID!
}

"""
Response payload of `updateProduct` mutation
"""
type UpdateProductPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Updated product
  """
  product: Product!
}

"""
Input for the `updateProductVariantField` mutation
"""
input UpdateProductVariantInput {
  """
  ID of shop that owns the variant to update
  """
  shopId: ID!

  """
  Variant input
  """
  variant: ProductVariantInput!

  """
  ID of variant to update
  """
  variantId: ID!
}

"""
Response payload of `updateProductVariantField` mutation
"""
type UpdateProductVariantPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Updated variant
  """
  variant: ProductVariant!
}

"""
Input for the `updateProductVariantField` mutation
"""
input UpdateProductVariantPricesInput {
  """
  Prices to update
  """
  prices: ProductVariantPricesInput!

  """
  ID of shop that owns the variant to update
  """
  shopId: ID!

  """
  ID of variant to update
  """
  variantId: ID!
}

"""
Response payload of `updateProductVariantPricesField` mutation
"""
type UpdateProductVariantPricesPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Updated variant
  """
  variant: ProductVariant!
}

"""
Input for the `updateProductsVisibility` mutation
"""
input UpdateProductsVisibilityInput {
  """
  The desired visibility
  """
  isVisible: Boolean!

  """
  Array of product ids to update
  """
  productIds: [ID]!

  """
  ID of shop the products belong to
  """
  shopId: ID!
}

"""
Response payload for `updateProductsVisibility` mutation
"""
type UpdateProductsVisibilityPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The number of products that were updated successfully
  """
  updatedCount: Int
}

"""
Input parameters for the updateShop mutation
"""
input UpdateShopInput {
  """
  An address book entry to set the primary shop's address
  """
  addressBook: [AddressInput]

  """
  Whether to allow user to checkout without creating an account
  """
  allowGuestCheckout: Boolean

  """
  The base unit of length
  """
  baseUOL: String

  """
  The base unit of Measure
  """
  baseUOM: String

  """
  ID of media record to be used as the brand asset
  """
  brandAssets: ID

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop's currency
  """
  currency: String

  """
  Default parcel size used for this shop
  """
  defaultParcelSize: ShopParcelSizeInput

  """
  The shop's description
  """
  description: String

  """
  The shops primary email address
  """
  emails: [EmailRecordInput]

  """
  The shop's keywords
  """
  keywords: String

  """
  The shop's language
  """
  language: String

  """
  The shop's name
  """
  name: String

  """
  The ID of the shop to update
  """
  shopId: ID!

  """
  Object of shop logo urls
  """
  shopLogoUrls: ShopLogoUrlsInput

  """
  Shop's slug
  """
  slug: String

  """
  Object of storefront routes urls
  """
  storefrontUrls: StorefrontUrlsInput

  """
  The shop's timezone
  """
  timezone: String
}

"""
The response from the `updateShop` mutation
"""
type UpdateShopPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The shop which was updated
  """
  shop: Shop!
}

"""
Input for the `updateShopSettings` mutation
"""
input UpdateShopSettingsInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Updated settings values. Only includes settings to be changed.
  """
  settingsUpdates: ShopSettingsUpdates!

  """
  The ID of the shop to update some settings for
  """
  shopId: ID!
}

"""
Response payload for the `updateShopSettings` mutation
"""
type UpdateShopSettingsPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  Updated shop settings
  """
  shopSettings: ShopSettings!
}

"""
Input for the `updateSimpleInventory` mutation. In addition to `shopId`, at least one field to update is required.
"""
input UpdateSimpleInventoryInput {
  """
  Whether to allow ordering this product configuration when there is insufficient quantity available.
  Set this to `true` or `false` if you want to update it.
  """
  canBackorder: Boolean

  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Current quantity of this product configuration in stock. Set this to an integer if you want to update it.
  """
  inventoryInStock: Int

  """
  Whether the SimpleInventory plugin should manage inventory for this product configuration.
  Set this to `true` or `false` if you want to update it.
  """
  isEnabled: Boolean

  """
  The "low quantity" flag will be applied to this product configuration when the available quantity
  is at or below this threshold. Set this to an integer if you want to update it.
  """
  lowInventoryWarningThreshold: Int

  """
  The product and chosen options this info applies to
  """
  productConfiguration: ProductConfigurationInput!

  """
  Shop that owns the product
  """
  shopId: ID!
}

"""
Response payload for the `updateSimpleInventory` mutation
"""
type UpdateSimpleInventoryPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated inventory info
  """
  inventoryInfo: SimpleInventoryInfo!
}

"""
Input for the `updateSurcharge` mutation
"""
input UpdateSurchargeInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  The shop that owns the method
  """
  shopId: ID!

  """
  The updated surcharge. Pass the whole updated surcharge object without the ID.
  """
  surcharge: SurchargeInput!

  """
  The ID of the flat rate fulfillment surcharge you want to update
  """
  surchargeId: ID!
}

"""
Response from the `updateFlatRateFulfillmentMethod` mutation
"""
type UpdateSurchargePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated fulfillment surcharge
  """
  surcharge: Surcharge!
}

"""
Input for `updateTag` mutation
"""
input UpdateTagInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  Title to display to customers
  """
  displayTitle: String

  """
  A list of the IDs of top products in this tag
  """
  featuredProductIds: [ID]

  """
  Hero media URL
  """
  heroMediaUrl: String

  """
  ID of rule to modify
  """
  id: ID!

  """
  Whether the tag is visible
  """
  isVisible: Boolean!

  """
  Tag metafields
  """
  metafields: [MetafieldInput]

  """
  Unique name of the tag
  """
  name: String!

  """
  The shop that owns the tag
  """
  shopId: ID!

  """
  The tag slug. If left blank, the name will be slugified and saved as the slug
  """
  slug: String
}

"""
Response payload for `updateTag` mutation
"""
type UpdateTagPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated tag
  """
  tag: Tag!
}

"""
The input for updating a tax rate. Note that missing values will cause the field to be cleared, so
send all optional fields with every request unless they aren't currently set or you intend to clear them.
"""
input UpdateTaxRateInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  An optional country code to limit where this tax is applied based on destination address
  """
  country: String

  """
  An optional postal code to limit where this tax is applied based on destination address
  """
  postal: String

  """
  The tax rate. For example, 0.05 for a 5% sales tax.
  """
  rate: Float!

  """
  An optional region (e.g., state) to limit where this tax is applied based on destination address
  """
  region: String

  """
  Shop ID
  """
  shopId: ID!

  """
  Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  """
  sourcing: TaxSource

  """
  An optional tax code, to apply this tax rate to only products that have this tax code
  """
  taxCode: String

  """
  ID of the tax rate you want to update
  """
  taxRateId: ID!
}

"""
The response from the `updateTaxRate` mutation
"""
type UpdateTaxRatePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated tax rate
  """
  taxRate: TaxRate!
}

"""
Input for `updateTemplate` mutation
"""
input UpdateTemplateInput {
  """
  An optional string identifying the mutation call, which will be returned in the response payload
  """
  clientMutationId: String

  """
  ID of template to modify
  """
  id: ID!

  """
  The shop that owns the template
  """
  shopId: ID!

  """
  Email template string
  """
  subject: String

  """
  Email template body or html text
  """
  template: String

  """
  Email template title
  """
  title: String
}

"""
Response payload for `updateTemplate` mutation
"""
type UpdateTemplatePayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  The updated template
  """
  template: Template!
}

type User {
  emails: [EmailRecord!]
  id: ID!
  username: String
}

input UserInput {
  email: String
  id: ID
  username: String
}

"""
"""
type Vendor {
  """
  The name of the vendor
  """
  name: String
}

"""
Wraps an array of vendors, providing pagination cursors and information.

For information about what Relay-compatible connections are and how to use them, see the following articles:
- [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
- [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
- [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
"""
type VendorConnection {
  """
  The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  """
  edges: [VendorEdge]

  """
  You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  if you know you will not need to paginate the results.
  """
  nodes: [Vendor]

  """
  Information to help a client request the next or previous page
  """
  pageInfo: PageInfo!

  """
  The total number of nodes that match your query
  """
  totalCount: Int!
}

"""
A connection edge in which each node is a String representing a vendor
"""
type VendorEdge {
  """
  The cursor that represents this node in the paginated results
  """
  cursor: ConnectionCursor!

  """
  The vendor
  """
  node: Vendor
}

"""
Input for an `VerifySMTPEmailSettingsInput`
"""
input VerifySMTPEmailSettingsInput {
  """
  The ID of the shop this setting belongs to
  """
  shopId: ID!
}

"""
Response payload for the verifySMTPEmailSettings mutation
"""
type VerifySMTPEmailSettingsInputPayload {
  """
  The same string you sent with the mutation params, for matching mutation calls with their responses
  """
  clientMutationId: String

  """
  True if the SMTP connection was made and authentication was successful.
  """
  isVerified: Boolean!
}

"""
A bulk write error type
"""
type WriteError {
  """
  The documentId(_id) on which the error occurred
  """
  documentId: Int

  """
  Error message for a documentId
  """
  errorMsg: String
}
